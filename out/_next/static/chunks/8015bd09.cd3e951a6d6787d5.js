"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[766],{59917:function(ar,G,e){e.d(G,{RG:function(){return b2},ew:function(){return b1},nh:function(){return c}});var j,p=e(64285),as=e(74736),m=e(15866),H=e(13384),at=e.n(H),I=e(77191),au=e.n(I),av=e(17748),aw=e(25532),b=e(39386),ax=e(40475),a=e(53471),ay=e(44115),J=e(31198),az=e.n(J),aA=e(85609),aB=e(9905),q=e(27760);m.P6.sha512Sync=(...a)=>(0,as.o)(m.P6.concatBytes(...a)),m.P6.randomPrivateKey;const aC=()=>{const b=m.P6.randomPrivateKey(),c=aD(b),a=new Uint8Array(64);return a.set(b),a.set(c,32),{publicKey:c,secretKey:a}},aD=m.Z_.getPublicKey;function aE(a){try{return m.E9.fromHex(a,!0),!0}catch{return!1}}const aF=(a,b)=>m.Z_.sign(a,b.slice(0,32)),aG=m.Z_.verify,aH=a=>p.lW.isBuffer(a)?a:a instanceof Uint8Array?p.lW.from(a.buffer,a.byteOffset,a.byteLength):p.lW.from(a);class K{constructor(a){Object.assign(this,a)}encode(){return p.lW.from((0,aw.serialize)(L,this))}static decode(a){return(0,aw.deserialize)(L,this,a)}static decodeUnchecked(a){return(0,aw.deserializeUnchecked)(L,this,a)}}const L=new Map,aI=32;let aJ=1;class c extends K{constructor(a){if(super({}),this._bn=void 0,void 0!==a._bn)this._bn=a._bn;else{if("string"==typeof a){const b=au().decode(a);if(b.length!=aI)throw new Error("Invalid public key input");this._bn=new(at())(b)}else this._bn=new(at())(a);if(this._bn.byteLength()>32)throw new Error("Invalid public key input")}}static unique(){const a=new c(aJ);return aJ+=1,new c(a.toBuffer())}equals(a){return this._bn.eq(a._bn)}toBase58(){return au().encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){return this.toBuffer()}toBuffer(){const a=this._bn.toArrayLike(p.lW);if(a.length===aI)return a;const b=p.lW.alloc(32);return a.copy(b,32-a.length),b}toString(){return this.toBase58()}static async createWithSeed(a,b,d){const e=p.lW.concat([a.toBuffer(),p.lW.from(b),d.toBuffer()]),f=(0,av.J)(e);return new c(f)}static createProgramAddressSync(d,e){let a=p.lW.alloc(0);d.forEach(function(b){if(b.length>32)throw new TypeError("Max seed length exceeded");a=p.lW.concat([a,aH(b)])}),a=p.lW.concat([a,e.toBuffer(),p.lW.from("ProgramDerivedAddress")]);const b=(0,av.J)(a);if(aE(b))throw new Error("Invalid seeds, address must fall off the curve");return new c(b)}static async createProgramAddress(a,b){return this.createProgramAddressSync(a,b)}static findProgramAddressSync(d,e){let a=255,b;for(;0!=a;){try{const f=d.concat(p.lW.from([a]));b=this.createProgramAddressSync(f,e)}catch(c){if(c instanceof TypeError)throw c;a--;continue}return[b,a]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(a,b){return this.findProgramAddressSync(a,b)}static isOnCurve(a){const b=new c(a);return aE(b.toBytes())}}c.default=new c("11111111111111111111111111111111"),L.set(c,{kind:"struct",fields:[["_bn","u256"]]}),new c("BPFLoader1111111111111111111111111111111111");const M=1232,N=64;class O extends Error{constructor(a){super(`Signature ${a} has expired: block height exceeded.`),this.signature=void 0,this.signature=a}}Object.defineProperty(O.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class P extends Error{constructor(a,b){super(`Transaction was not confirmed in ${b.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${a} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=a}}Object.defineProperty(P.prototype,"name",{value:"TransactionExpiredTimeoutError"});class aK{constructor(a,b){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=a,this.accountKeysFromLookups=b}keySegments(){const a=[this.staticAccountKeys];return this.accountKeysFromLookups&&(a.push(this.accountKeysFromLookups.writable),a.push(this.accountKeysFromLookups.readonly)),a}get(a){for(const b of this.keySegments()){if(a<b.length)return b[a];a-=b.length}}get length(){return this.keySegments().flat().length}compileInstructions(a){if(this.length>256)throw new Error("Account index overflow encountered during compilation");const b=new Map;this.keySegments().flat().forEach((a,c)=>{b.set(a.toBase58(),c)});const c=c=>{const a=b.get(c.toBase58());if(void 0===a)throw new Error("Encountered an unknown instruction account key during compilation");return a};return a.map(a=>({programIdIndex:c(a.programId),accountKeyIndexes:a.keys.map(a=>c(a.pubkey)),data:a.data}))}}const d=(a="publicKey")=>b.Ik(32,a),aL=(a="signature")=>BufferLayout.blob(64,a),l=(d="string")=>{const a=b.n_([b.Jq("length"),b.Jq("lengthPadding"),b.Ik(b.cv(b.Jq(),-8),"chars")],d),e=a.decode.bind(a),f=a.encode.bind(a),c=a;return c.decode=(a,b)=>{const c=e(a,b);return c.chars.toString()},c.encode=(a,b,c)=>{const d={chars:p.lW.from(a,"utf8")};return f(d,b,c)},c.alloc=a=>b.Jq().span+b.Jq().span+p.lW.from(a,"utf8").length,c};function aM(a,c){const d=a=>{if(a.span>=0)return a.span;if("function"==typeof a.alloc)return a.alloc(c[a.property]);if("count"in a&&"elementLayout"in a){const b=c[a.property];if(Array.isArray(b))return b.length*d(a.elementLayout)}else if("fields"in a)return aM({layout:a},c[a.property]);return 0};let b=0;return a.layout.fields.forEach(a=>{b+=d(a)}),b}function aN(d){let a=0,b=0;for(;;){let c=d.shift();if(a|=(127&c)<<7*b,b+=1,(128&c)==0)break}return a}function aO(b,d){let c=d;for(;;){let a=127&c;if(0==(c>>=7)){b.push(a);break}a|=128,b.push(a)}}function aP(a,b){if(!a)throw new Error(b||"Assertion failed")}class aQ{constructor(a,b){this.payer=void 0,this.keyMetaMap=void 0,this.payer=a,this.keyMetaMap=b}static compile(g,d){const h=new Map,b=c=>{const b=c.toBase58();let a=h.get(b);return void 0===a&&(a={isSigner:!1,isWritable:!1,isInvoked:!1},h.set(b,a)),a},e=b(d);for(const f of(e.isSigner=!0,e.isWritable=!0,g))for(const c of(b(f.programId).isInvoked=!0,f.keys)){const a=b(c.pubkey);a.isSigner||(a.isSigner=c.isSigner),a.isWritable||(a.isWritable=c.isWritable)}return new aQ(d,h)}getMessageComponents(){const a=[...this.keyMetaMap.entries()];aP(a.length<=256,"Max static account keys length exceeded");const b=a.filter(([,a])=>a.isSigner&&a.isWritable),d=a.filter(([,a])=>a.isSigner&&!a.isWritable),f=a.filter(([,a])=>!a.isSigner&&a.isWritable),e=a.filter(([,a])=>!a.isSigner&&!a.isWritable),g={numRequiredSignatures:b.length+d.length,numReadonlySignedAccounts:d.length,numReadonlyUnsignedAccounts:e.length};{aP(b.length>0,"Expected at least one writable signer key");const[h]=b[0];aP(h===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const i=[...b.map(([a])=>new c(a)),...d.map(([a])=>new c(a)),...f.map(([a])=>new c(a)),...e.map(([a])=>new c(a))];return[g,i]}extractTableLookup(a){const[b,d]=this.drainKeysFoundInLookupTable(a.state.addresses,a=>!a.isSigner&&!a.isInvoked&&a.isWritable),[c,e]=this.drainKeysFoundInLookupTable(a.state.addresses,a=>!a.isSigner&&!a.isInvoked&&!a.isWritable);if(0!==b.length||0!==c.length)return[{accountKey:a.key,writableIndexes:b,readonlyIndexes:c},{writable:d,readonly:e}]}drainKeysFoundInLookupTable(f,g){const b=new Array,d=new Array;for(const[e,h]of this.keyMetaMap.entries())if(g(h)){const i=new c(e),a=f.findIndex(a=>a.equals(i));a>=0&&(aP(a<256,"Max lookup table index exceeded"),b.push(a),d.push(i),this.keyMetaMap.delete(e))}return[b,d]}}class aR{constructor(a){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=a.header,this.accountKeys=a.accountKeys.map(a=>new c(a)),this.recentBlockhash=a.recentBlockhash,this.instructions=a.instructions,this.instructions.forEach(a=>this.indexToProgramIds.set(a.programIdIndex,this.accountKeys[a.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(a=>({programIdIndex:a.programIdIndex,accountKeyIndexes:a.accounts,data:au().decode(a.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new aK(this.staticAccountKeys)}static compile(a){const c=aQ.compile(a.instructions,a.payerKey),[d,b]=c.getMessageComponents(),e=new aK(b),f=e.compileInstructions(a.instructions).map(a=>({programIdIndex:a.programIdIndex,accounts:a.accountKeyIndexes,data:au().encode(a.data)}));return new aR({header:d,accountKeys:b,recentBlockhash:a.recentBlockhash,instructions:f})}isAccountSigner(a){return a<this.header.numRequiredSignatures}isAccountWritable(a){const b=this.header.numRequiredSignatures;if(a>=this.header.numRequiredSignatures){const c=a-b,d=this.accountKeys.length-b,e=d-this.header.numReadonlyUnsignedAccounts;return c<e}{const f=b-this.header.numReadonlySignedAccounts;return a<f}}isProgramId(a){return this.indexToProgramIds.has(a)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((b,a)=>!this.isProgramId(a))}serialize(){const g=this.accountKeys.length;let c=[];aO(c,g);const h=this.instructions.map(a=>{const{accounts:b,programIdIndex:f}=a,c=Array.from(au().decode(a.data));let d=[];aO(d,b.length);let e=[];return aO(e,c.length),{programIdIndex:f,keyIndicesCount:p.lW.from(d),keyIndices:b,dataLength:p.lW.from(e),data:c}});let e=[];aO(e,h.length);let a=p.lW.alloc(M);p.lW.from(e).copy(a);let j=e.length;h.forEach(c=>{const d=b.n_([b.u8("programIdIndex"),b.Ik(c.keyIndicesCount.length,"keyIndicesCount"),b.A9(b.u8("keyIndex"),c.keyIndices.length,"keyIndices"),b.Ik(c.dataLength.length,"dataLength"),b.A9(b.u8("userdatum"),c.data.length,"data")]),e=d.encode(c,a,j);j+=e}),a=a.slice(0,j);const k=b.n_([b.Ik(1,"numRequiredSignatures"),b.Ik(1,"numReadonlySignedAccounts"),b.Ik(1,"numReadonlyUnsignedAccounts"),b.Ik(c.length,"keyCount"),b.A9(d("key"),g,"keys"),d("recentBlockhash")]),l={numRequiredSignatures:p.lW.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:p.lW.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:p.lW.from([this.header.numReadonlyUnsignedAccounts]),keyCount:p.lW.from(c),keys:this.accountKeys.map(a=>aH(a.toBytes())),recentBlockhash:au().decode(this.recentBlockhash)};let f=p.lW.alloc(2048);const i=k.encode(l,f);return a.copy(f,i),f.slice(0,i+a.length)}static from(j){let a=[...j];const b=a.shift();if(b!==(127&b))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const k=a.shift(),l=a.shift(),m=aN(a);let d=[];for(let e=0;e<m;e++){const n=a.slice(0,aI);a=a.slice(aI),d.push(new c(p.lW.from(n)))}const o=a.slice(0,aI);a=a.slice(aI);const q=aN(a);let f=[];for(let g=0;g<q;g++){const r=a.shift(),h=aN(a),s=a.slice(0,h);a=a.slice(h);const i=aN(a),t=a.slice(0,i),u=au().encode(p.lW.from(t));a=a.slice(i),f.push({programIdIndex:r,accounts:s,data:u})}const v={header:{numRequiredSignatures:b,numReadonlySignedAccounts:k,numReadonlyUnsignedAccounts:l},recentBlockhash:au().encode(p.lW.from(o)),accountKeys:d,instructions:f};return new aR(v)}}class aS{constructor(a){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=a.header,this.staticAccountKeys=a.staticAccountKeys,this.recentBlockhash=a.recentBlockhash,this.compiledInstructions=a.compiledInstructions,this.addressTableLookups=a.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let a=0;for(const b of this.addressTableLookups)a+=b.readonlyIndexes.length+b.writableIndexes.length;return a}getAccountKeys(a){let b;if(a&&"accountKeysFromLookups"in a&&a.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=a.accountKeysFromLookups.writable.length+a.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");b=a.accountKeysFromLookups}else if(a&&"addressLookupTableAccounts"in a&&a.addressLookupTableAccounts)b=this.resolveAddressTableLookups(a.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new aK(this.staticAccountKeys,b)}isAccountSigner(a){return a<this.header.numRequiredSignatures}isAccountWritable(a){const b=this.header.numRequiredSignatures,c=this.staticAccountKeys.length;if(a>=c){const d=a-c,e=this.addressTableLookups.reduce((a,b)=>a+b.writableIndexes.length,0);return d<e}if(a>=this.header.numRequiredSignatures){const f=a-b,g=c-b,h=g-this.header.numReadonlyUnsignedAccounts;return f<h}{const i=b-this.header.numReadonlySignedAccounts;return a<i}}resolveAddressTableLookups(f){const c={writable:[],readonly:[]};for(const a of this.addressTableLookups){const b=f.find(b=>b.key.equals(a.accountKey));if(!b)throw new Error(`Failed to find address lookup table account for table key ${a.accountKey.toBase58()}`);for(const d of a.writableIndexes)if(d<b.state.addresses.length)c.writable.push(b.state.addresses[d]);else throw new Error(`Failed to find address for index ${d} in address lookup table ${a.accountKey.toBase58()}`);for(const e of a.readonlyIndexes)if(e<b.state.addresses.length)c.readonly.push(b.state.addresses[e]);else throw new Error(`Failed to find address for index ${e} in address lookup table ${a.accountKey.toBase58()}`)}return c}static compile(a){const c=aQ.compile(a.instructions,a.payerKey),d=new Array,b={writable:new Array,readonly:new Array},g=a.addressLookupTableAccounts||[];for(const h of g){const e=c.extractTableLookup(h);if(void 0!==e){const[i,{writable:j,readonly:k}]=e;d.push(i),b.writable.push(...j),b.readonly.push(...k)}}const[l,f]=c.getMessageComponents(),m=new aK(f,b),n=m.compileInstructions(a.instructions);return new aS({header:l,staticAccountKeys:f,recentBlockhash:a.recentBlockhash,compiledInstructions:n,addressTableLookups:d})}serialize(){const a=Array();aO(a,this.staticAccountKeys.length);const f=this.serializeInstructions(),c=Array();aO(c,this.compiledInstructions.length);const g=this.serializeAddressTableLookups(),e=Array();aO(e,this.addressTableLookups.length);const i=b.n_([b.u8("prefix"),b.n_([b.u8("numRequiredSignatures"),b.u8("numReadonlySignedAccounts"),b.u8("numReadonlyUnsignedAccounts")],"header"),b.Ik(a.length,"staticAccountKeysLength"),b.A9(d(),this.staticAccountKeys.length,"staticAccountKeys"),d("recentBlockhash"),b.Ik(c.length,"instructionsLength"),b.Ik(f.length,"serializedInstructions"),b.Ik(e.length,"addressTableLookupsLength"),b.Ik(g.length,"serializedAddressTableLookups")]),h=new Uint8Array(M),j=i.encode({prefix:128,header:this.header,staticAccountKeysLength:new Uint8Array(a),staticAccountKeys:this.staticAccountKeys.map(a=>a.toBytes()),recentBlockhash:au().decode(this.recentBlockhash),instructionsLength:new Uint8Array(c),serializedInstructions:f,addressTableLookupsLength:new Uint8Array(e),serializedAddressTableLookups:g},h);return h.slice(0,j)}serializeInstructions(){let c=0;const f=new Uint8Array(M);for(const a of this.compiledInstructions){const d=Array();aO(d,a.accountKeyIndexes.length);const e=Array();aO(e,a.data.length);const g=b.n_([b.u8("programIdIndex"),b.Ik(d.length,"encodedAccountKeyIndexesLength"),b.A9(b.u8(),a.accountKeyIndexes.length,"accountKeyIndexes"),b.Ik(e.length,"encodedDataLength"),b.Ik(a.data.length,"data")]);c+=g.encode({programIdIndex:a.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(d),accountKeyIndexes:a.accountKeyIndexes,encodedDataLength:new Uint8Array(e),data:a.data},f,c)}return f.slice(0,c)}serializeAddressTableLookups(){let c=0;const g=new Uint8Array(M);for(const a of this.addressTableLookups){const e=Array();aO(e,a.writableIndexes.length);const f=Array();aO(f,a.readonlyIndexes.length);const h=b.n_([d("accountKey"),b.Ik(e.length,"encodedWritableIndexesLength"),b.A9(b.u8(),a.writableIndexes.length,"writableIndexes"),b.Ik(f.length,"encodedReadonlyIndexesLength"),b.A9(b.u8(),a.readonlyIndexes.length,"readonlyIndexes")]);c+=h.encode({accountKey:a.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(e),writableIndexes:a.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(f),readonlyIndexes:a.readonlyIndexes},g,c)}return g.slice(0,c)}static deserialize(l){let a=[...l];const b=a.shift(),d=127&b;aP(b!==d,"Expected versioned message but received legacy message");const e=d;aP(0===e,`Expected versioned message with version 0 but found version ${e}`);const m={numRequiredSignatures:a.shift(),numReadonlySignedAccounts:a.shift(),numReadonlyUnsignedAccounts:a.shift()},f=[],n=aN(a);for(let g=0;g<n;g++)f.push(new c(a.splice(0,aI)));const o=au().encode(a.splice(0,aI)),p=aN(a),h=[];for(let i=0;i<p;i++){const q=a.shift(),r=aN(a),s=a.splice(0,r),t=aN(a),u=new Uint8Array(a.splice(0,t));h.push({programIdIndex:q,accountKeyIndexes:s,data:u})}const v=aN(a),j=[];for(let k=0;k<v;k++){const w=new c(a.splice(0,aI)),x=aN(a),y=a.splice(0,x),z=aN(a),A=a.splice(0,z);j.push({accountKey:w,writableIndexes:y,readonlyIndexes:A})}return new aS({header:m,staticAccountKeys:f,recentBlockhash:o,compiledInstructions:h,addressTableLookups:j})}}const aT={deserializeMessageVersion(c){const a=c[0],b=127&a;return b===a?"legacy":b},deserialize(a){const b=aT.deserializeMessageVersion(a);if("legacy"===b)return aR.from(a);if(0===b)return aS.deserialize(a);throw new Error(`Transaction message version ${b} deserialization is not supported`)}};let w;(j=w||(w={}))[j.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",j[j.PROCESSED=1]="PROCESSED",j[j.TIMED_OUT=2]="TIMED_OUT";const aU=p.lW.alloc(N).fill(0);class aV{constructor(a){this.keys=void 0,this.programId=void 0,this.data=p.lW.alloc(0),this.programId=a.programId,this.keys=a.keys,a.data&&(this.data=a.data)}toJSON(){return{keys:this.keys.map(({pubkey:a,isSigner:b,isWritable:c})=>({pubkey:a.toJSON(),isSigner:b,isWritable:c})),programId:this.programId.toJSON(),data:[...this.data]}}}class aW{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(a){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this._message=void 0,this._json=void 0,!a)return;if(a.feePayer&&(this.feePayer=a.feePayer),a.signatures&&(this.signatures=a.signatures),Object.prototype.hasOwnProperty.call(a,"lastValidBlockHeight")){const{blockhash:c,lastValidBlockHeight:d}=a;this.recentBlockhash=c,this.lastValidBlockHeight=d}else{const{recentBlockhash:e,nonceInfo:b}=a;b&&(this.nonceInfo=b),this.recentBlockhash=e}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(a=>a.toJSON()),signers:this.signatures.map(({publicKey:a})=>a.toJSON())}}add(...a){if(0===a.length)throw new Error("No instructions");return a.forEach(a=>{"instructions"in a?this.instructions=this.instructions.concat(a.instructions):"data"in a&&"programId"in a&&"keys"in a?this.instructions.push(a):this.instructions.push(new aV(a))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let d,b;if(this.nonceInfo?(d=this.nonceInfo.nonce,b=this.instructions[0]!=this.nonceInfo.nonceInstruction?[this.nonceInfo.nonceInstruction,...this.instructions]:this.instructions):(d=this.recentBlockhash,b=this.instructions),!d)throw new Error("Transaction recentBlockhash required");b.length<1&&console.warn("No instructions provided");let f;if(this.feePayer)f=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)f=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let e=0;e<b.length;e++)if(void 0===b[e].programId)throw new Error(`Transaction instruction index ${e} has undefined program id`);const k=[],l=[];b.forEach(a=>{a.keys.forEach(a=>{l.push({...a})});const b=a.programId.toString();k.includes(b)||k.push(b)}),k.forEach(a=>{l.push({pubkey:new c(a),isSigner:!1,isWritable:!1})});const a=[];l.forEach(c=>{const d=c.pubkey.toString(),b=a.findIndex(a=>a.pubkey.toString()===d);b> -1?(a[b].isWritable=a[b].isWritable||c.isWritable,a[b].isSigner=a[b].isSigner||c.isSigner):a.push(c)}),a.sort(function(a,b){return a.isSigner!==b.isSigner?a.isSigner?-1:1:a.isWritable!==b.isWritable?a.isWritable?-1:1:a.pubkey.toBase58().localeCompare(b.pubkey.toBase58())});const i=a.findIndex(a=>a.pubkey.equals(f));if(i> -1){const[g]=a.splice(i,1);g.isSigner=!0,g.isWritable=!0,a.unshift(g)}else a.unshift({pubkey:f,isSigner:!0,isWritable:!0});for(const m of this.signatures){const h=a.findIndex(a=>a.pubkey.equals(m.publicKey));if(h> -1)a[h].isSigner||(a[h].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${m.publicKey.toString()}`)}let n=0,o=0,p=0;const q=[],r=[];a.forEach(({pubkey:a,isSigner:c,isWritable:b})=>{c?(q.push(a.toString()),n+=1,b||(o+=1)):(r.push(a.toString()),b||(p+=1))});const s=q.concat(r),j=b.map(a=>{const{data:b,programId:c}=a;return{programIdIndex:s.indexOf(c.toString()),accounts:a.keys.map(a=>s.indexOf(a.pubkey.toString())),data:au().encode(b)}});return j.forEach(a=>{aP(a.programIdIndex>=0),a.accounts.forEach(a=>aP(a>=0))}),new aR({header:{numRequiredSignatures:n,numReadonlySignedAccounts:o,numReadonlyUnsignedAccounts:p},accountKeys:s,recentBlockhash:d,instructions:j})}_compile(){const a=this.compileMessage(),b=a.accountKeys.slice(0,a.header.numRequiredSignatures);if(this.signatures.length===b.length){const c=this.signatures.every((a,c)=>b[c].equals(a.publicKey));if(c)return a}return this.signatures=b.map(a=>({signature:null,publicKey:a})),a}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(a){return(await a.getFeeForMessage(this.compileMessage())).value}setSigners(...a){if(0===a.length)throw new Error("No signers");const b=new Set;this.signatures=a.filter(c=>{const a=c.toString();return!b.has(a)&&(b.add(a),!0)}).map(a=>({signature:null,publicKey:a}))}sign(...b){if(0===b.length)throw new Error("No signers");const c=new Set,a=[];for(const d of b){const e=d.publicKey.toString();c.has(e)||(c.add(e),a.push(d))}this.signatures=a.map(a=>({signature:null,publicKey:a.publicKey}));const f=this._compile();this._partialSign(f,...a)}partialSign(...a){if(0===a.length)throw new Error("No signers");const b=new Set,c=[];for(const d of a){const e=d.publicKey.toString();b.has(e)||(b.add(e),c.push(d))}const f=this._compile();this._partialSign(f,...c)}_partialSign(a,...b){const c=a.serialize();b.forEach(a=>{const b=aF(c,a.secretKey);this._addSignature(a.publicKey,aH(b))})}addSignature(a,b){this._compile(),this._addSignature(a,b)}_addSignature(c,a){aP(64===a.length);const b=this.signatures.findIndex(a=>c.equals(a.publicKey));if(b<0)throw new Error(`unknown signer: ${c.toString()}`);this.signatures[b].signature=p.lW.from(a)}verifySignatures(){return this._verifySignatures(this.serializeMessage(),!0)}_verifySignatures(b,c){for(const{signature:a,publicKey:d}of this.signatures)if(null===a){if(c)return!1}else if(!aG(a,b,d.toBuffer()))return!1;return!0}serialize(b){const{requireAllSignatures:c,verifySignatures:d}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},b),a=this.serializeMessage();if(d&&!this._verifySignatures(a,c))throw new Error("Signature verification failed");return this._serialize(a)}_serialize(d){const{signatures:a}=this,c=[];aO(c,a.length);const e=c.length+64*a.length+d.length,b=p.lW.alloc(e);return aP(a.length<256),p.lW.from(c).copy(b,0),a.forEach(({signature:a},d)=>{null!==a&&(aP(64===a.length,"signature has invalid length"),p.lW.from(a).copy(b,c.length+64*d))}),d.copy(b,c.length+64*a.length),aP(b.length<=M,`Transaction too large: ${b.length} > ${M}`),b}get keys(){return aP(1===this.instructions.length),this.instructions[0].keys.map(a=>a.pubkey)}get programId(){return aP(1===this.instructions.length),this.instructions[0].programId}get data(){return aP(1===this.instructions.length),this.instructions[0].data}static from(d){let a=[...d];const e=aN(a);let b=[];for(let c=0;c<e;c++){const f=a.slice(0,N);a=a.slice(N),b.push(au().encode(p.lW.from(f)))}return aW.populate(aR.from(a),b)}static populate(b,c=[]){const a=new aW;return a.recentBlockhash=b.recentBlockhash,b.header.numRequiredSignatures>0&&(a.feePayer=b.accountKeys[0]),c.forEach((c,d)=>{const e={signature:c==au().encode(aU)?null:au().decode(c),publicKey:b.accountKeys[d]};a.signatures.push(e)}),b.instructions.forEach(c=>{const d=c.accounts.map(c=>{const d=b.accountKeys[c];return{pubkey:d,isSigner:a.signatures.some(a=>a.publicKey.toString()===d.toString())||b.isAccountSigner(c),isWritable:b.isAccountWritable(c)}});a.instructions.push(new aV({keys:d,programId:b.accountKeys[c.programIdIndex],data:au().decode(c.data)}))}),a._message=b,a._json=a.toJSON(),a}}class aX{constructor(a){this.payerKey=void 0,this.instructions=void 0,this.recentBlockhash=void 0,this.payerKey=a.payerKey,this.instructions=a.instructions,this.recentBlockhash=a.recentBlockhash}static decompile(d,o){const{header:f,compiledInstructions:p,recentBlockhash:q}=d,{numRequiredSignatures:e,numReadonlySignedAccounts:r,numReadonlyUnsignedAccounts:s}=f,g=e-r;aP(g>0,"Message header is invalid");const h=d.staticAccountKeys.length-s;aP(h>=0,"Message header is invalid");const b=d.getAccountKeys(o),i=b.get(0);if(void 0===i)throw new Error("Failed to decompile message because no account keys were found");const j=[];for(const c of p){const k=[];for(const a of c.accountKeyIndexes){const l=b.get(a);if(void 0===l)throw new Error(`Failed to find key for account key index ${a}`);const t=a<e;let m;m=t?a<g:a<b.staticAccountKeys.length?a-e<h:a-b.staticAccountKeys.length<b.accountKeysFromLookups.writable.length,k.push({pubkey:l,isSigner:a<f.numRequiredSignatures,isWritable:m})}const n=b.get(c.programIdIndex);if(void 0===n)throw new Error(`Failed to find program id for program id index ${c.programIdIndex}`);j.push(new aV({programId:n,data:aH(c.data),keys:k}))}return new aX({payerKey:i,instructions:j,recentBlockhash:q})}compileToLegacyMessage(){return aR.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions})}compileToV0Message(a){return aS.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions,addressLookupTableAccounts:a})}}class aY{get version(){return this.message.version}constructor(a,b){if(this.signatures=void 0,this.message=void 0,void 0!==b)aP(b.length===a.header.numRequiredSignatures,"Expected signatures length to be equal to the number of required signatures"),this.signatures=b;else{const c=[];for(let d=0;d<a.header.numRequiredSignatures;d++)c.push(new Uint8Array(N));this.signatures=c}this.message=a}serialize(){const b=this.message.serialize(),a=Array();aO(a,this.signatures.length);const d=BufferLayout.struct([BufferLayout.blob(a.length,"encodedSignaturesLength"),BufferLayout.seq(aL(),this.signatures.length,"signatures"),BufferLayout.blob(b.length,"serializedMessage")]),c=new Uint8Array(2048),e=d.encode({encodedSignaturesLength:new Uint8Array(a),signatures:this.signatures,serializedMessage:b},c);return c.slice(0,e)}static deserialize(d){let a=[...d];const b=[],e=aN(a);for(let c=0;c<e;c++)b.push(new Uint8Array(a.splice(0,N)));const f=aT.deserialize(new Uint8Array(a));return new aY(f,b)}sign(c){const d=this.message.serialize(),e=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures);for(const a of c){const b=e.findIndex(b=>b.equals(a.publicKey));aP(b>=0,`Cannot sign with non signer key ${a.publicKey.toBase58()}`),this.signatures[b]=aF(d,a.secretKey)}}addSignature(c,a){aP(64===a.byteLength,"Signature must be 64 bytes long");const d=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures),b=d.findIndex(a=>a.equals(c));aP(b>=0,`Can not add signature; \`${c.toBase58()}\` is not required to sign this transaction`),this.signatures[b]=a}}const aZ=new c("SysvarC1ock11111111111111111111111111111111");new c("SysvarEpochSchedu1e111111111111111111111111"),new c("Sysvar1nstructions1111111111111111111111111");const a$=new c("SysvarRecentB1ockHashes11111111111111111111"),a_=new c("SysvarRent111111111111111111111111111111111");new c("SysvarRewards111111111111111111111111111111"),new c("SysvarS1otHashes111111111111111111111111111"),new c("SysvarS1otHistory11111111111111111111111111");const a0=new c("SysvarStakeHistory1111111111111111111111111");async function a1(d,b,f,a){const g=a&&{skipPreflight:a.skipPreflight,preflightCommitment:a.preflightCommitment||a.commitment,maxRetries:a.maxRetries,minContextSlot:a.minContextSlot},c=await d.sendTransaction(b,f,g),e=null!=b.recentBlockhash&&null!=b.lastValidBlockHeight?(await d.confirmTransaction({signature:c,blockhash:b.recentBlockhash,lastValidBlockHeight:b.lastValidBlockHeight},a&&a.commitment)).value:(await d.confirmTransaction(c,a&&a.commitment)).value;if(e.err)throw new Error(`Transaction ${c} failed (${JSON.stringify(e)})`);return c}function a2(a){return new Promise(b=>setTimeout(b,a))}function a3(a,b){const d=a.layout.span>=0?a.layout.span:aM(a,b),c=p.lW.alloc(d),e=Object.assign({instruction:a.index},b);return a.layout.encode(e,c),c}const Q=b._O("lamportsPerSignature"),R=b.n_([b.Jq("version"),b.Jq("state"),d("authorizedPubkey"),d("nonce"),b.n_([Q],"feeCalculator")]),a4=R.span;class a5{constructor(a){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=a.authorizedPubkey,this.nonce=a.nonce,this.feeCalculator=a.feeCalculator}static fromAccountData(b){const a=R.decode(aH(b),0);return new a5({authorizedPubkey:new c(a.authorizedPubkey),nonce:new c(a.nonce).toString(),feeCalculator:a.feeCalculator})}}const a6=a=>{const b=a.decode.bind(a),c=a.encode.bind(a);return{decode:b,encode:c}},k=d=>{const c=(0,b.Ik)(8,d),{encode:e,decode:f}=a6(c),a=c;return a.decode=(a,b)=>{const c=f(a,b);return(0,ax.oU)(p.lW.from(c))},a.encode=(a,b,c)=>{const d=(0,ax.k$)(a,8);return e(d,b,c)},a},a7=Object.freeze({Create:{index:0,layout:b.n_([b.Jq("instruction"),b.gM("lamports"),b.gM("space"),d("programId")])},Assign:{index:1,layout:b.n_([b.Jq("instruction"),d("programId")])},Transfer:{index:2,layout:b.n_([b.Jq("instruction"),k("lamports")])},CreateWithSeed:{index:3,layout:b.n_([b.Jq("instruction"),d("base"),l("seed"),b.gM("lamports"),b.gM("space"),d("programId")])},AdvanceNonceAccount:{index:4,layout:b.n_([b.Jq("instruction")])},WithdrawNonceAccount:{index:5,layout:b.n_([b.Jq("instruction"),b.gM("lamports")])},InitializeNonceAccount:{index:6,layout:b.n_([b.Jq("instruction"),d("authorized")])},AuthorizeNonceAccount:{index:7,layout:b.n_([b.Jq("instruction"),d("authorized")])},Allocate:{index:8,layout:b.n_([b.Jq("instruction"),b.gM("space")])},AllocateWithSeed:{index:9,layout:b.n_([b.Jq("instruction"),d("base"),l("seed"),b.gM("space"),d("programId")])},AssignWithSeed:{index:10,layout:b.n_([b.Jq("instruction"),d("base"),l("seed"),d("programId")])},TransferWithSeed:{index:11,layout:b.n_([b.Jq("instruction"),k("lamports"),l("seed"),d("programId")])},UpgradeNonceAccount:{index:12,layout:b.n_([b.Jq("instruction")])}});class S{constructor(){}static createAccount(a){const b=a7.Create,c=a3(b,{lamports:a.lamports,space:a.space,programId:aH(a.programId.toBuffer())});return new aV({keys:[{pubkey:a.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:a.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:c})}static transfer(a){let b,c;if("basePubkey"in a){const d=a7.TransferWithSeed;b=a3(d,{lamports:BigInt(a.lamports),seed:a.seed,programId:aH(a.programId.toBuffer())}),c=[{pubkey:a.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:a.basePubkey,isSigner:!0,isWritable:!1},{pubkey:a.toPubkey,isSigner:!1,isWritable:!0}]}else{const e=a7.Transfer;b=a3(e,{lamports:BigInt(a.lamports)}),c=[{pubkey:a.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:a.toPubkey,isSigner:!1,isWritable:!0}]}return new aV({keys:c,programId:this.programId,data:b})}static assign(a){let b,c;if("basePubkey"in a){const d=a7.AssignWithSeed;b=a3(d,{base:aH(a.basePubkey.toBuffer()),seed:a.seed,programId:aH(a.programId.toBuffer())}),c=[{pubkey:a.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:a.basePubkey,isSigner:!0,isWritable:!1}]}else{const e=a7.Assign;b=a3(e,{programId:aH(a.programId.toBuffer())}),c=[{pubkey:a.accountPubkey,isSigner:!0,isWritable:!0}]}return new aV({keys:c,programId:this.programId,data:b})}static createAccountWithSeed(a){const c=a7.CreateWithSeed,d=a3(c,{base:aH(a.basePubkey.toBuffer()),seed:a.seed,lamports:a.lamports,space:a.space,programId:aH(a.programId.toBuffer())});let b=[{pubkey:a.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:a.newAccountPubkey,isSigner:!1,isWritable:!0}];return a.basePubkey!=a.fromPubkey&&b.push({pubkey:a.basePubkey,isSigner:!0,isWritable:!1}),new aV({keys:b,programId:this.programId,data:d})}static createNonceAccount(a){const b=new aW;"basePubkey"in a&&"seed"in a?b.add(S.createAccountWithSeed({fromPubkey:a.fromPubkey,newAccountPubkey:a.noncePubkey,basePubkey:a.basePubkey,seed:a.seed,lamports:a.lamports,space:a4,programId:this.programId})):b.add(S.createAccount({fromPubkey:a.fromPubkey,newAccountPubkey:a.noncePubkey,lamports:a.lamports,space:a4,programId:this.programId}));const c={noncePubkey:a.noncePubkey,authorizedPubkey:a.authorizedPubkey};return b.add(this.nonceInitialize(c)),b}static nonceInitialize(a){const b=a7.InitializeNonceAccount,c=a3(b,{authorized:aH(a.authorizedPubkey.toBuffer())}),d={keys:[{pubkey:a.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:a$,isSigner:!1,isWritable:!1},{pubkey:a_,isSigner:!1,isWritable:!1}],programId:this.programId,data:c};return new aV(d)}static nonceAdvance(a){const b=a7.AdvanceNonceAccount,c=a3(b),d={keys:[{pubkey:a.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:a$,isSigner:!1,isWritable:!1},{pubkey:a.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:c};return new aV(d)}static nonceWithdraw(a){const b=a7.WithdrawNonceAccount,c=a3(b,{lamports:a.lamports});return new aV({keys:[{pubkey:a.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:a.toPubkey,isSigner:!1,isWritable:!0},{pubkey:a$,isSigner:!1,isWritable:!1},{pubkey:a_,isSigner:!1,isWritable:!1},{pubkey:a.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:c})}static nonceAuthorize(a){const b=a7.AuthorizeNonceAccount,c=a3(b,{authorized:aH(a.newAuthorizedPubkey.toBuffer())});return new aV({keys:[{pubkey:a.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:a.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:c})}static allocate(a){let b,c;if("basePubkey"in a){const d=a7.AllocateWithSeed;b=a3(d,{base:aH(a.basePubkey.toBuffer()),seed:a.seed,space:a.space,programId:aH(a.programId.toBuffer())}),c=[{pubkey:a.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:a.basePubkey,isSigner:!0,isWritable:!1}]}else{const e=a7.Allocate;b=a3(e,{space:a.space}),c=[{pubkey:a.accountPubkey,isSigner:!0,isWritable:!0}]}return new aV({keys:c,programId:this.programId,data:b})}}S.programId=new c("11111111111111111111111111111111");class T{constructor(){}static getMinNumSignatures(a){return 2*(Math.ceil(a/T.chunkSize)+1+1)}static async load(d,f,a,g,h){{const i=await d.getMinimumBalanceForRentExemption(h.length),e=await d.getAccountInfo(a.publicKey,"confirmed");let c=null;if(null!==e){if(e.executable)return console.error("Program load failed, account is already executable"),!1;e.data.length!==h.length&&(c=c||new aW).add(S.allocate({accountPubkey:a.publicKey,space:h.length})),e.owner.equals(g)||(c=c||new aW).add(S.assign({accountPubkey:a.publicKey,programId:g})),e.lamports<i&&(c=c||new aW).add(S.transfer({fromPubkey:f.publicKey,toPubkey:a.publicKey,lamports:i-e.lamports}))}else c=new aW().add(S.createAccount({fromPubkey:f.publicKey,newAccountPubkey:a.publicKey,lamports:i>0?i:1,space:h.length,programId:g}));null!==c&&await a1(d,c,[f,a],{commitment:"confirmed"})}const r=b.n_([b.Jq("instruction"),b.Jq("offset"),b.Jq("bytesLength"),b.Jq("bytesLengthPadding"),b.A9(b.u8("byte"),b.cv(b.Jq(),-8),"bytes")]),j=T.chunkSize;let l=0,k=h,m=[];for(;k.length>0;){const s=k.slice(0,j),n=p.lW.alloc(j+16);r.encode({instruction:0,offset:l,bytes:s,bytesLength:0,bytesLengthPadding:0},n);const t=new aW().add({keys:[{pubkey:a.publicKey,isSigner:!0,isWritable:!0}],programId:g,data:n});if(m.push(a1(d,t,[f,a],{commitment:"confirmed"})),d._rpcEndpoint.includes("solana.com")){const u=4;await a2(1e3/u)}l+=j,k=k.slice(j)}await Promise.all(m);{const o=b.n_([b.Jq("instruction")]),q=p.lW.alloc(o.span);o.encode({instruction:1},q);const v=new aW().add({keys:[{pubkey:a.publicKey,isSigner:!0,isWritable:!0},{pubkey:a_,isSigner:!1,isWritable:!1}],programId:g,data:q});await a1(d,v,[f,a],{commitment:"confirmed"})}return!0}}T.chunkSize=M-300,new c("BPFLoader2111111111111111111111111111111111");var a8=Object.prototype.toString,a9=Object.keys||function(b){var a=[];for(var c in b)a.push(c);return a};function ba(a,e){var b,d,c,f,g,h,i;if(!0===a)return"true";if(!1===a)return"false";switch(typeof a){case"object":if(null===a)return null;if(a.toJSON&&"function"==typeof a.toJSON)return ba(a.toJSON(),e);if("[object Array]"===(i=a8.call(a))){for(b=0,c="[",d=a.length-1;b<d;b++)c+=ba(a[b],!0)+",";return d> -1&&(c+=ba(a[b],!0)),c+"]"}if("[object Object]"!==i)return JSON.stringify(a);for(d=(f=a9(a).sort()).length,c="",b=0;b<d;)void 0!==(h=ba(a[g=f[b]],!1))&&(c&&(c+=","),c+=JSON.stringify(g)+":"+h),b++;return"{"+c+"}";case"function":case"undefined":return e?null:void 0;case"string":return JSON.stringify(a);default:return isFinite(a)?a:null}}var bb=function(b){var a=ba(b,!1);if(void 0!==a)return""+a};function bc(a){let b=0;for(;a>1;)a/=2,b++;return b}class bd{constructor(a,b,c,d,e){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=a,this.leaderScheduleSlotOffset=b,this.warmup=c,this.firstNormalEpoch=d,this.firstNormalSlot=e}getEpoch(a){return this.getEpochAndSlotIndex(a)[0]}getEpochAndSlotIndex(b){if(b<this.firstNormalSlot){var a;const c=bc(0===(a=b+32+1)?1:(a--,a|=a>>1,a|=a>>2,a|=a>>4,a|=a>>8,a|=a>>16,a|=a>>32,a+1))-bc(32)-1,e=this.getSlotsInEpoch(c),f=b-(e-32);return[c,f]}{const d=b-this.firstNormalSlot,g=Math.floor(d/this.slotsPerEpoch),h=this.firstNormalEpoch+g,i=d%this.slotsPerEpoch;return[h,i]}}getFirstSlotInEpoch(a){return a<=this.firstNormalEpoch?(Math.pow(2,a)-1)*32:(a-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(a){return this.getFirstSlotInEpoch(a)+this.getSlotsInEpoch(a)-1}getSlotsInEpoch(a){return a<this.firstNormalEpoch?Math.pow(2,a+bc(32)):this.slotsPerEpoch}}class be extends Error{constructor(a,b){super(a),this.logs=void 0,this.logs=b}}class bf extends Error{constructor({code:c,message:a,data:d},b){super(null!=b?`${b}: ${a}`:a),this.code=void 0,this.data=void 0,this.code=c,this.data=d,this.name="SolanaJSONRPCError"}}var bg=globalThis.fetch;class bh{constructor(a){this.key=void 0,this.state=void 0,this.key=a.key,this.state=a.state}isActive(){const a=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===a}static deserialize(e){const a=function(b,c){let a;try{a=b.layout.decode(c)}catch(d){throw new Error("invalid instruction; "+d)}if(a.typeIndex!==b.index)throw new Error(`invalid account data; account type mismatch ${a.typeIndex} != ${b.index}`);return a}(bi,e),f=e.length-56;aP(f>=0,"lookup table is invalid"),aP(f%32==0,"lookup table is invalid");const{addresses:g}=b.n_([b.A9(d(),f/32,"addresses")]).decode(e.slice(56));return{deactivationSlot:a.deactivationSlot,lastExtendedSlot:a.lastExtendedSlot,lastExtendedSlotStartIndex:a.lastExtendedStartIndex,authority:0!==a.authority.length?new c(a.authority[0]):void 0,addresses:g.map(a=>new c(a))}}}const bi={index:1,layout:b.n_([b.Jq("typeIndex"),k("deactivationSlot"),b._O("lastExtendedSlot"),b.u8("lastExtendedStartIndex"),b.u8(),b.A9(d(),b.cv(b.u8(),-1),"authority")])},bj=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i,f=(0,a.oQ)((0,a.eE)(c),(0,a.Z_)(),a=>new c(a)),x=(0,a.bc)([(0,a.Z_)(),(0,a.i0)("base64")]),y=(0,a.oQ)((0,a.eE)(p.lW),x,a=>p.lW.from(a[0],"base64"));function bk(a){let b,c;if("string"==typeof a)b=a;else if(a){const{commitment:d,...e}=a;b=d,c=e}return{commitment:b,config:c}}function U(b){return(0,a.G0)([(0,a.dt)({jsonrpc:(0,a.i0)("2.0"),id:(0,a.Z_)(),result:b}),(0,a.dt)({jsonrpc:(0,a.i0)("2.0"),id:(0,a.Z_)(),error:(0,a.dt)({code:(0,a._4)(),message:(0,a.Z_)(),data:(0,a.jt)((0,a.Yj)())})})])}const bl=U((0,a._4)());function g(b){return(0,a.oQ)(U(b),bl,c=>"error"in c?c:{...c,result:(0,a.Ue)(c.result,b)})}function h(b){return g((0,a.dt)({context:(0,a.dt)({slot:(0,a.Rx)()}),value:b}))}function n(b){return(0,a.dt)({context:(0,a.dt)({slot:(0,a.Rx)()}),value:b})}function bm(b,a){return 0===b?new aS({header:a.header,staticAccountKeys:a.accountKeys.map(a=>new c(a)),recentBlockhash:a.recentBlockhash,compiledInstructions:a.instructions.map(a=>({programIdIndex:a.programIdIndex,accountKeyIndexes:a.accounts,data:au().decode(a.data)})),addressTableLookups:a.addressTableLookups}):new aR(a)}const V=(0,a.dt)({foundation:(0,a.Rx)(),foundationTerm:(0,a.Rx)(),initial:(0,a.Rx)(),taper:(0,a.Rx)(),terminal:(0,a.Rx)()}),bn=g((0,a.IX)((0,a.AG)((0,a.dt)({epoch:(0,a.Rx)(),effectiveSlot:(0,a.Rx)(),amount:(0,a.Rx)(),postBalance:(0,a.Rx)()})))),W=(0,a.dt)({epoch:(0,a.Rx)(),slotIndex:(0,a.Rx)(),slotsInEpoch:(0,a.Rx)(),absoluteSlot:(0,a.Rx)(),blockHeight:(0,a.jt)((0,a.Rx)()),transactionCount:(0,a.jt)((0,a.Rx)())}),X=(0,a.dt)({slotsPerEpoch:(0,a.Rx)(),leaderScheduleSlotOffset:(0,a.Rx)(),warmup:(0,a.O7)(),firstNormalEpoch:(0,a.Rx)(),firstNormalSlot:(0,a.Rx)()}),Y=(0,a.IM)((0,a.Z_)(),(0,a.IX)((0,a.Rx)())),i=(0,a.AG)((0,a.G0)([(0,a.dt)({}),(0,a.Z_)()])),Z=(0,a.dt)({err:i}),$=(0,a.i0)("receivedSignature"),bo=(0,a.dt)({"solana-core":(0,a.Z_)(),"feature-set":(0,a.jt)((0,a.Rx)())}),bp=h((0,a.dt)({err:(0,a.AG)((0,a.G0)([(0,a.dt)({}),(0,a.Z_)()])),logs:(0,a.AG)((0,a.IX)((0,a.Z_)())),accounts:(0,a.jt)((0,a.AG)((0,a.IX)((0,a.AG)((0,a.dt)({executable:(0,a.O7)(),owner:(0,a.Z_)(),lamports:(0,a.Rx)(),data:(0,a.IX)((0,a.Z_)()),rentEpoch:(0,a.jt)((0,a.Rx)())}))))),unitsConsumed:(0,a.jt)((0,a.Rx)()),returnData:(0,a.jt)((0,a.AG)((0,a.dt)({programId:(0,a.Z_)(),data:(0,a.bc)([(0,a.Z_)(),(0,a.i0)("base64")])})))})),bq=h((0,a.dt)({byIdentity:(0,a.IM)((0,a.Z_)(),(0,a.IX)((0,a.Rx)())),range:(0,a.dt)({firstSlot:(0,a.Rx)(),lastSlot:(0,a.Rx)()})})),br=g(V),bs=g(W),bt=g(X),bu=g(Y),bv=g((0,a.Rx)()),bw=h((0,a.dt)({total:(0,a.Rx)(),circulating:(0,a.Rx)(),nonCirculating:(0,a.Rx)(),nonCirculatingAccounts:(0,a.IX)(f)})),_=(0,a.dt)({amount:(0,a.Z_)(),uiAmount:(0,a.AG)((0,a.Rx)()),decimals:(0,a.Rx)(),uiAmountString:(0,a.jt)((0,a.Z_)())}),bx=h((0,a.IX)((0,a.dt)({address:f,amount:(0,a.Z_)(),uiAmount:(0,a.AG)((0,a.Rx)()),decimals:(0,a.Rx)(),uiAmountString:(0,a.jt)((0,a.Z_)())}))),by=h((0,a.IX)((0,a.dt)({pubkey:f,account:(0,a.dt)({executable:(0,a.O7)(),owner:f,lamports:(0,a.Rx)(),data:y,rentEpoch:(0,a.Rx)()})}))),r=(0,a.dt)({program:(0,a.Z_)(),parsed:(0,a._4)(),space:(0,a.Rx)()}),bz=h((0,a.IX)((0,a.dt)({pubkey:f,account:(0,a.dt)({executable:(0,a.O7)(),owner:f,lamports:(0,a.Rx)(),data:r,rentEpoch:(0,a.Rx)()})}))),bA=h((0,a.IX)((0,a.dt)({lamports:(0,a.Rx)(),address:f}))),s=(0,a.dt)({executable:(0,a.O7)(),owner:f,lamports:(0,a.Rx)(),data:y,rentEpoch:(0,a.Rx)()}),bB=(0,a.dt)({pubkey:f,account:s}),aa=(0,a.oQ)((0,a.G0)([(0,a.eE)(p.lW),r]),(0,a.G0)([x,r]),b=>Array.isArray(b)?(0,a.Ue)(b,y):b),ab=(0,a.dt)({executable:(0,a.O7)(),owner:f,lamports:(0,a.Rx)(),data:aa,rentEpoch:(0,a.Rx)()}),bC=(0,a.dt)({pubkey:f,account:ab}),bD=(0,a.dt)({state:(0,a.G0)([(0,a.i0)("active"),(0,a.i0)("inactive"),(0,a.i0)("activating"),(0,a.i0)("deactivating")]),active:(0,a.Rx)(),inactive:(0,a.Rx)()}),bE=g((0,a.IX)((0,a.dt)({signature:(0,a.Z_)(),slot:(0,a.Rx)(),err:i,memo:(0,a.AG)((0,a.Z_)()),blockTime:(0,a.jt)((0,a.AG)((0,a.Rx)()))}))),bF=g((0,a.IX)((0,a.dt)({signature:(0,a.Z_)(),slot:(0,a.Rx)(),err:i,memo:(0,a.AG)((0,a.Z_)()),blockTime:(0,a.jt)((0,a.AG)((0,a.Rx)()))}))),bG=(0,a.dt)({subscription:(0,a.Rx)(),result:n(s)}),ac=(0,a.dt)({pubkey:f,account:s}),bH=(0,a.dt)({subscription:(0,a.Rx)(),result:n(ac)}),ad=(0,a.dt)({parent:(0,a.Rx)(),slot:(0,a.Rx)(),root:(0,a.Rx)()}),bI=(0,a.dt)({subscription:(0,a.Rx)(),result:ad}),ae=(0,a.G0)([(0,a.dt)({type:(0,a.G0)([(0,a.i0)("firstShredReceived"),(0,a.i0)("completed"),(0,a.i0)("optimisticConfirmation"),(0,a.i0)("root")]),slot:(0,a.Rx)(),timestamp:(0,a.Rx)()}),(0,a.dt)({type:(0,a.i0)("createdBank"),parent:(0,a.Rx)(),slot:(0,a.Rx)(),timestamp:(0,a.Rx)()}),(0,a.dt)({type:(0,a.i0)("frozen"),slot:(0,a.Rx)(),timestamp:(0,a.Rx)(),stats:(0,a.dt)({numTransactionEntries:(0,a.Rx)(),numSuccessfulTransactions:(0,a.Rx)(),numFailedTransactions:(0,a.Rx)(),maxTransactionsPerEntry:(0,a.Rx)()})}),(0,a.dt)({type:(0,a.i0)("dead"),slot:(0,a.Rx)(),timestamp:(0,a.Rx)(),err:(0,a.Z_)()})]),bJ=(0,a.dt)({subscription:(0,a.Rx)(),result:ae}),bK=(0,a.dt)({subscription:(0,a.Rx)(),result:n((0,a.G0)([Z,$]))}),bL=(0,a.dt)({subscription:(0,a.Rx)(),result:(0,a.Rx)()}),bM=(0,a.dt)({pubkey:(0,a.Z_)(),gossip:(0,a.AG)((0,a.Z_)()),tpu:(0,a.AG)((0,a.Z_)()),rpc:(0,a.AG)((0,a.Z_)()),version:(0,a.AG)((0,a.Z_)())}),z=(0,a.dt)({votePubkey:(0,a.Z_)(),nodePubkey:(0,a.Z_)(),activatedStake:(0,a.Rx)(),epochVoteAccount:(0,a.O7)(),epochCredits:(0,a.IX)((0,a.bc)([(0,a.Rx)(),(0,a.Rx)(),(0,a.Rx)()])),commission:(0,a.Rx)(),lastVote:(0,a.Rx)(),rootSlot:(0,a.AG)((0,a.Rx)())}),bN=g((0,a.dt)({current:(0,a.IX)(z),delinquent:(0,a.IX)(z)})),af=(0,a.G0)([(0,a.i0)("processed"),(0,a.i0)("confirmed"),(0,a.i0)("finalized")]),ag=(0,a.dt)({slot:(0,a.Rx)(),confirmations:(0,a.AG)((0,a.Rx)()),err:i,confirmationStatus:(0,a.jt)(af)}),bO=h((0,a.IX)((0,a.AG)(ag))),bP=g((0,a.Rx)()),A=(0,a.dt)({accountKey:f,writableIndexes:(0,a.IX)((0,a.Rx)()),readonlyIndexes:(0,a.IX)((0,a.Rx)())}),t=(0,a.dt)({signatures:(0,a.IX)((0,a.Z_)()),message:(0,a.dt)({accountKeys:(0,a.IX)((0,a.Z_)()),header:(0,a.dt)({numRequiredSignatures:(0,a.Rx)(),numReadonlySignedAccounts:(0,a.Rx)(),numReadonlyUnsignedAccounts:(0,a.Rx)()}),instructions:(0,a.IX)((0,a.dt)({accounts:(0,a.IX)((0,a.Rx)()),data:(0,a.Z_)(),programIdIndex:(0,a.Rx)()})),recentBlockhash:(0,a.Z_)(),addressTableLookups:(0,a.jt)((0,a.IX)(A))})}),ah=(0,a.dt)({parsed:(0,a._4)(),program:(0,a.Z_)(),programId:f}),ai=(0,a.dt)({accounts:(0,a.IX)(f),data:(0,a.Z_)(),programId:f}),aj=(0,a.G0)([ai,ah]),ak=(0,a.G0)([(0,a.dt)({parsed:(0,a._4)(),program:(0,a.Z_)(),programId:(0,a.Z_)()}),(0,a.dt)({accounts:(0,a.IX)((0,a.Z_)()),data:(0,a.Z_)(),programId:(0,a.Z_)()})]),B=(0,a.oQ)(aj,ak,b=>"accounts"in b?(0,a.Ue)(b,ai):(0,a.Ue)(b,ah)),al=(0,a.dt)({signatures:(0,a.IX)((0,a.Z_)()),message:(0,a.dt)({accountKeys:(0,a.IX)((0,a.dt)({pubkey:f,signer:(0,a.O7)(),writable:(0,a.O7)(),source:(0,a.jt)((0,a.G0)([(0,a.i0)("transaction"),(0,a.i0)("lookupTable")]))})),instructions:(0,a.IX)(B),recentBlockhash:(0,a.Z_)(),addressTableLookups:(0,a.jt)((0,a.AG)((0,a.IX)(A)))})}),o=(0,a.dt)({accountIndex:(0,a.Rx)(),mint:(0,a.Z_)(),owner:(0,a.jt)((0,a.Z_)()),uiTokenAmount:_}),C=(0,a.dt)({writable:(0,a.IX)(f),readonly:(0,a.IX)(f)}),u=(0,a.dt)({err:i,fee:(0,a.Rx)(),innerInstructions:(0,a.jt)((0,a.AG)((0,a.IX)((0,a.dt)({index:(0,a.Rx)(),instructions:(0,a.IX)((0,a.dt)({accounts:(0,a.IX)((0,a.Rx)()),data:(0,a.Z_)(),programIdIndex:(0,a.Rx)()}))})))),preBalances:(0,a.IX)((0,a.Rx)()),postBalances:(0,a.IX)((0,a.Rx)()),logMessages:(0,a.jt)((0,a.AG)((0,a.IX)((0,a.Z_)()))),preTokenBalances:(0,a.jt)((0,a.AG)((0,a.IX)(o))),postTokenBalances:(0,a.jt)((0,a.AG)((0,a.IX)(o))),loadedAddresses:(0,a.jt)(C),computeUnitsConsumed:(0,a.jt)((0,a.Rx)())}),am=(0,a.dt)({err:i,fee:(0,a.Rx)(),innerInstructions:(0,a.jt)((0,a.AG)((0,a.IX)((0,a.dt)({index:(0,a.Rx)(),instructions:(0,a.IX)(B)})))),preBalances:(0,a.IX)((0,a.Rx)()),postBalances:(0,a.IX)((0,a.Rx)()),logMessages:(0,a.jt)((0,a.AG)((0,a.IX)((0,a.Z_)()))),preTokenBalances:(0,a.jt)((0,a.AG)((0,a.IX)(o))),postTokenBalances:(0,a.jt)((0,a.AG)((0,a.IX)(o))),loadedAddresses:(0,a.jt)(C),computeUnitsConsumed:(0,a.jt)((0,a.Rx)())}),v=(0,a.G0)([(0,a.i0)(0),(0,a.i0)("legacy")]),bQ=g((0,a.AG)((0,a.dt)({blockhash:(0,a.Z_)(),previousBlockhash:(0,a.Z_)(),parentSlot:(0,a.Rx)(),transactions:(0,a.IX)((0,a.dt)({transaction:t,meta:(0,a.AG)(u),version:(0,a.jt)(v)})),rewards:(0,a.jt)((0,a.IX)((0,a.dt)({pubkey:(0,a.Z_)(),lamports:(0,a.Rx)(),postBalance:(0,a.AG)((0,a.Rx)()),rewardType:(0,a.AG)((0,a.Z_)())}))),blockTime:(0,a.AG)((0,a.Rx)()),blockHeight:(0,a.AG)((0,a.Rx)())}))),bR=g((0,a.AG)((0,a.dt)({blockhash:(0,a.Z_)(),previousBlockhash:(0,a.Z_)(),parentSlot:(0,a.Rx)(),transactions:(0,a.IX)((0,a.dt)({transaction:t,meta:(0,a.AG)(u)})),rewards:(0,a.jt)((0,a.IX)((0,a.dt)({pubkey:(0,a.Z_)(),lamports:(0,a.Rx)(),postBalance:(0,a.AG)((0,a.Rx)()),rewardType:(0,a.AG)((0,a.Z_)())}))),blockTime:(0,a.AG)((0,a.Rx)())}))),bS=g((0,a.AG)((0,a.dt)({blockhash:(0,a.Z_)(),previousBlockhash:(0,a.Z_)(),parentSlot:(0,a.Rx)(),signatures:(0,a.IX)((0,a.Z_)()),blockTime:(0,a.AG)((0,a.Rx)())}))),bT=g((0,a.AG)((0,a.dt)({slot:(0,a.Rx)(),meta:u,blockTime:(0,a.jt)((0,a.AG)((0,a.Rx)())),transaction:t,version:(0,a.jt)(v)}))),bU=g((0,a.AG)((0,a.dt)({slot:(0,a.Rx)(),transaction:al,meta:(0,a.AG)(am),blockTime:(0,a.jt)((0,a.AG)((0,a.Rx)())),version:(0,a.jt)(v)}))),bV=h((0,a.dt)({blockhash:(0,a.Z_)(),feeCalculator:(0,a.dt)({lamportsPerSignature:(0,a.Rx)()})})),bW=h((0,a.dt)({blockhash:(0,a.Z_)(),lastValidBlockHeight:(0,a.Rx)()})),an=(0,a.dt)({slot:(0,a.Rx)(),numTransactions:(0,a.Rx)(),numSlots:(0,a.Rx)(),samplePeriodSecs:(0,a.Rx)()}),bX=g((0,a.IX)(an)),bY=h((0,a.AG)((0,a.dt)({feeCalculator:(0,a.dt)({lamportsPerSignature:(0,a.Rx)()})}))),bZ=g((0,a.Z_)()),b$=g((0,a.Z_)()),ao=(0,a.dt)({err:i,logs:(0,a.IX)((0,a.Z_)()),signature:(0,a.Z_)()}),b_=(0,a.dt)({result:n(ao),subscription:(0,a.Rx)()}),b0={"solana-client":"js/0.0.0-development"};class b1{constructor(b,a){var h,i;this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set;let c,d,e,f,g;a&&"string"==typeof a?this._commitment=a:a&&(this._commitment=a.commitment,this._confirmTransactionInitialTimeout=a.confirmTransactionInitialTimeout,c=a.wsEndpoint,d=a.httpHeaders,e=a.fetch,f=a.fetchMiddleware,g=a.disableRetryOnRateLimit),this._rpcEndpoint=function(a){if(!1===/^https?:/.test(a))throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return a}(b),this._rpcWsEndpoint=c||function(a){const b=a.match(bj);if(null==b)throw TypeError(`Failed to validate endpoint URL \`${a}\``);const[i,e,c,f]=b,g=a.startsWith("https:")?"wss:":"ws:",d=null==c?null:parseInt(c.slice(1),10),h=null==d?"":`:${d+1}`;return`${g}//${e}${h}${f}`}(b),this._rpcClient=function(e,f,a,b,g){const h=a||bg;let c;b&&(c=async(c,d)=>{const a=await new Promise((f,a)=>{try{b(c,d,(a,b)=>f([a,b]))}catch(e){a(e)}});return await h(...a)});const d=new(az())(async(m,b)=>{const i={method:"POST",body:m,agent:void 0,headers:Object.assign({"Content-Type":"application/json"},f||{},b0)};try{let j=5,a,d=500;for(;a=c?await c(e,i):await h(e,i),429===a.status&& !0!==g&&(j-=1,0!==j);)console.log(`Server responded with ${a.status} ${a.statusText}.  Retrying after ${d}ms delay...`),await a2(d),d*=2;const k=await a.text();a.ok?b(null,k):b(new Error(`${a.status} ${a.statusText}: ${k}`))}catch(l){l instanceof Error&&b(l)}finally{}},{});return d}(b,d,e,f,g),this._rpcRequest=(h=this._rpcClient,(a,b)=>new Promise((c,d)=>{h.request(a,b,(a,b)=>{if(a){d(a);return}c(b)})})),this._rpcBatchRequest=(i=this._rpcClient,a=>new Promise((b,d)=>{0===a.length&&b([]);const c=a.map(a=>i.request(a.methodName,a.args));i.request(c,(a,c)=>{if(a){d(a);return}b(c)})})),this._rpcWebSocket=new ay.K(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(c,d){const{commitment:e,config:f}=bk(d),g=this._buildArgs([c.toBase58()],e,void 0,f),i=await this._rpcRequest("getBalance",g),b=(0,a.Ue)(i,h((0,a.Rx)()));if("error"in b)throw new bf(b.error,`failed to get balance for ${c.toBase58()}`);return b.result}async getBalance(a,b){return await this.getBalanceAndContext(a,b).then(a=>a.value).catch(b=>{throw new Error("failed to get balance of account "+a.toBase58()+": "+b)})}async getBlockTime(c){const d=await this._rpcRequest("getBlockTime",[c]),b=(0,a.Ue)(d,g((0,a.AG)((0,a.Rx)())));if("error"in b)throw new bf(b.error,`failed to get block time for slot ${c}`);return b.result}async getMinimumLedgerSlot(){const c=await this._rpcRequest("minimumLedgerSlot",[]),b=(0,a.Ue)(c,g((0,a.Rx)()));if("error"in b)throw new bf(b.error,"failed to get minimum ledger slot");return b.result}async getFirstAvailableBlock(){const c=await this._rpcRequest("getFirstAvailableBlock",[]),b=(0,a.Ue)(c,bv);if("error"in b)throw new bf(b.error,"failed to get first available block");return b.result}async getSupply(b){let d={};d="string"==typeof b?{commitment:b}:b?{...b,commitment:b&&b.commitment||this.commitment}:{commitment:this.commitment};const e=await this._rpcRequest("getSupply",[d]),c=(0,a.Ue)(e,bw);if("error"in c)throw new bf(c.error,"failed to get supply");return c.result}async getTokenSupply(c,d){const e=this._buildArgs([c.toBase58()],d),f=await this._rpcRequest("getTokenSupply",e),b=(0,a.Ue)(f,h(_));if("error"in b)throw new bf(b.error,"failed to get token supply");return b.result}async getTokenAccountBalance(c,d){const e=this._buildArgs([c.toBase58()],d),f=await this._rpcRequest("getTokenAccountBalance",e),b=(0,a.Ue)(f,h(_));if("error"in b)throw new bf(b.error,"failed to get token account balance");return b.result}async getTokenAccountsByOwner(e,b,f){const{commitment:g,config:h}=bk(f);let c=[e.toBase58()];"mint"in b?c.push({mint:b.mint.toBase58()}):c.push({programId:b.programId.toBase58()});const i=this._buildArgs(c,g,"base64",h),j=await this._rpcRequest("getTokenAccountsByOwner",i),d=(0,a.Ue)(j,by);if("error"in d)throw new bf(d.error,`failed to get token accounts owned by account ${e.toBase58()}`);return d.result}async getParsedTokenAccountsByOwner(e,b,f){let c=[e.toBase58()];"mint"in b?c.push({mint:b.mint.toBase58()}):c.push({programId:b.programId.toBase58()});const g=this._buildArgs(c,f,"jsonParsed"),h=await this._rpcRequest("getTokenAccountsByOwner",g),d=(0,a.Ue)(h,bz);if("error"in d)throw new bf(d.error,`failed to get token accounts owned by account ${e.toBase58()}`);return d.result}async getLargestAccounts(b){const c={...b,commitment:b&&b.commitment||this.commitment},e=c.filter||c.commitment?[c]:[],f=await this._rpcRequest("getLargestAccounts",e),d=(0,a.Ue)(f,bA);if("error"in d)throw new bf(d.error,"failed to get largest accounts");return d.result}async getTokenLargestAccounts(c,d){const e=this._buildArgs([c.toBase58()],d),f=await this._rpcRequest("getTokenLargestAccounts",e),b=(0,a.Ue)(f,bx);if("error"in b)throw new bf(b.error,"failed to get token largest accounts");return b.result}async getAccountInfoAndContext(c,d){const{commitment:e,config:f}=bk(d),g=this._buildArgs([c.toBase58()],e,"base64",f),i=await this._rpcRequest("getAccountInfo",g),b=(0,a.Ue)(i,h((0,a.AG)(s)));if("error"in b)throw new bf(b.error,`failed to get info about account ${c.toBase58()}`);return b.result}async getParsedAccountInfo(c,d){const{commitment:e,config:f}=bk(d),g=this._buildArgs([c.toBase58()],e,"jsonParsed",f),i=await this._rpcRequest("getAccountInfo",g),b=(0,a.Ue)(i,h((0,a.AG)(ab)));if("error"in b)throw new bf(b.error,`failed to get info about account ${c.toBase58()}`);return b.result}async getAccountInfo(a,b){try{const c=await this.getAccountInfoAndContext(a,b);return c.value}catch(d){throw new Error("failed to get info about account "+a.toBase58()+": "+d)}}async getMultipleAccountsInfoAndContext(d,e){const{commitment:f,config:g}=bk(e),c=d.map(a=>a.toBase58()),i=this._buildArgs([c],f,"base64",g),j=await this._rpcRequest("getMultipleAccounts",i),b=(0,a.Ue)(j,h((0,a.IX)((0,a.AG)(s))));if("error"in b)throw new bf(b.error,`failed to get info for accounts ${c}`);return b.result}async getMultipleAccountsInfo(a,b){const c=await this.getMultipleAccountsInfoAndContext(a,b);return c.value}async getStakeActivation(d,f,e){const{commitment:h,config:b}=bk(f),i=this._buildArgs([d.toBase58()],h,void 0,{...b,epoch:null!=e?e:null==b?void 0:b.epoch}),j=await this._rpcRequest("getStakeActivation",i),c=(0,a.Ue)(j,g(bD));if("error"in c)throw new bf(c.error,`failed to get Stake Activation ${d.toBase58()}`);return c.result}async getProgramAccounts(c,d){const{commitment:e,config:f}=bk(d),{encoding:h,...i}=f||{},j=this._buildArgs([c.toBase58()],e,h||"base64",i),k=await this._rpcRequest("getProgramAccounts",j),b=(0,a.Ue)(k,g((0,a.IX)(bB)));if("error"in b)throw new bf(b.error,`failed to get accounts owned by program ${c.toBase58()}`);return b.result}async getParsedProgramAccounts(c,d){const{commitment:e,config:f}=bk(d),h=this._buildArgs([c.toBase58()],e,"jsonParsed",f),i=await this._rpcRequest("getProgramAccounts",h),b=(0,a.Ue)(i,g((0,a.IX)(bC)));if("error"in b)throw new bf(b.error,`failed to get accounts owned by program ${c.toBase58()}`);return b.result}async confirmTransaction(b,g){let a;if("string"==typeof b)a=b;else{const h=b;a=h.signature}let d;try{d=au().decode(a)}catch(l){throw new Error("signature must be base58 encoded: "+a)}aP(64===d.length,"signature has invalid length");const m=g||this.commitment;let i,e,n=!1;const j=new Promise((d,b)=>{try{e=this.onSignature(a,(a,b)=>{e=void 0;const c={context:b,value:a};n=!0,d({__type:w.PROCESSED,response:c})},m)}catch(c){b(c)}}),k=new Promise(c=>{if("string"==typeof b){let a=this._confirmTransactionInitialTimeout||6e4;switch(m){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":a=this._confirmTransactionInitialTimeout||3e4;break}i=setTimeout(()=>c({__type:w.TIMED_OUT,timeoutMs:a}),a)}else{let d=b;const e=async()=>{try{const a=await this.getBlockHeight(g);return a}catch(b){return -1}};(async()=>{let a=await e();if(!n){for(;a<=d.lastValidBlockHeight;){if(await a2(1e3),n)return;if(a=await e(),n)return}c({__type:w.BLOCKHEIGHT_EXCEEDED})}})()}});let f;try{const c=await Promise.race([j,k]);switch(c.__type){case w.BLOCKHEIGHT_EXCEEDED:throw new O(a);case w.PROCESSED:f=c.response;break;case w.TIMED_OUT:throw new P(a,c.timeoutMs/1e3)}}finally{clearTimeout(i),e&&this.removeSignatureListener(e)}return f}async getClusterNodes(){const c=await this._rpcRequest("getClusterNodes",[]),b=(0,a.Ue)(c,g((0,a.IX)(bM)));if("error"in b)throw new bf(b.error,"failed to get cluster nodes");return b.result}async getVoteAccounts(c){const d=this._buildArgs([],c),e=await this._rpcRequest("getVoteAccounts",d),b=(0,a.Ue)(e,bN);if("error"in b)throw new bf(b.error,"failed to get vote accounts");return b.result}async getSlot(c){const{commitment:d,config:e}=bk(c),f=this._buildArgs([],d,void 0,e),h=await this._rpcRequest("getSlot",f),b=(0,a.Ue)(h,g((0,a.Rx)()));if("error"in b)throw new bf(b.error,"failed to get slot");return b.result}async getSlotLeader(c){const{commitment:d,config:e}=bk(c),f=this._buildArgs([],d,void 0,e),h=await this._rpcRequest("getSlotLeader",f),b=(0,a.Ue)(h,g((0,a.Z_)()));if("error"in b)throw new bf(b.error,"failed to get slot leader");return b.result}async getSlotLeaders(c,d){const e=await this._rpcRequest("getSlotLeaders",[c,d]),b=(0,a.Ue)(e,g((0,a.IX)(f)));if("error"in b)throw new bf(b.error,"failed to get slot leaders");return b.result}async getSignatureStatus(b,c){const{context:d,value:a}=await this.getSignatureStatuses([b],c);aP(1===a.length);const e=a[0];return{context:d,value:e}}async getSignatureStatuses(e,c){const d=[e];c&&d.push(c);const f=await this._rpcRequest("getSignatureStatuses",d),b=(0,a.Ue)(f,bO);if("error"in b)throw new bf(b.error,"failed to get signature status");return b.result}async getTransactionCount(c){const{commitment:d,config:e}=bk(c),f=this._buildArgs([],d,void 0,e),h=await this._rpcRequest("getTransactionCount",f),b=(0,a.Ue)(h,g((0,a.Rx)()));if("error"in b)throw new bf(b.error,"failed to get transaction count");return b.result}async getTotalSupply(a){const b=await this.getSupply({commitment:a,excludeNonCirculatingAccountsList:!0});return b.value.total}async getInflationGovernor(c){const d=this._buildArgs([],c),e=await this._rpcRequest("getInflationGovernor",d),b=(0,a.Ue)(e,br);if("error"in b)throw new bf(b.error,"failed to get inflation");return b.result}async getInflationReward(e,d,f){const{commitment:g,config:b}=bk(f),h=this._buildArgs([e.map(a=>a.toBase58())],g,void 0,{...b,epoch:null!=d?d:null==b?void 0:b.epoch}),i=await this._rpcRequest("getInflationReward",h),c=(0,a.Ue)(i,bn);if("error"in c)throw new bf(c.error,"failed to get inflation reward");return c.result}async getEpochInfo(c){const{commitment:d,config:e}=bk(c),f=this._buildArgs([],d,void 0,e),g=await this._rpcRequest("getEpochInfo",f),b=(0,a.Ue)(g,bs);if("error"in b)throw new bf(b.error,"failed to get epoch info");return b.result}async getEpochSchedule(){const d=await this._rpcRequest("getEpochSchedule",[]),c=(0,a.Ue)(d,bt);if("error"in c)throw new bf(c.error,"failed to get epoch schedule");const b=c.result;return new bd(b.slotsPerEpoch,b.leaderScheduleSlotOffset,b.warmup,b.firstNormalEpoch,b.firstNormalSlot)}async getLeaderSchedule(){const c=await this._rpcRequest("getLeaderSchedule",[]),b=(0,a.Ue)(c,bu);if("error"in b)throw new bf(b.error,"failed to get leader schedule");return b.result}async getMinimumBalanceForRentExemption(c,d){const e=this._buildArgs([c],d),f=await this._rpcRequest("getMinimumBalanceForRentExemption",e),b=(0,a.Ue)(f,bP);return"error"in b?(console.warn("Unable to fetch minimum balance for rent exemption"),0):b.result}async getRecentBlockhashAndContext(c){const d=this._buildArgs([],c),e=await this._rpcRequest("getRecentBlockhash",d),b=(0,a.Ue)(e,bV);if("error"in b)throw new bf(b.error,"failed to get recent blockhash");return b.result}async getRecentPerformanceSamples(c){const d=await this._rpcRequest("getRecentPerformanceSamples",c?[c]:[]),b=(0,a.Ue)(d,bX);if("error"in b)throw new bf(b.error,"failed to get recent performance samples");return b.result}async getFeeCalculatorForBlockhash(d,e){const f=this._buildArgs([d],e),g=await this._rpcRequest("getFeeCalculatorForBlockhash",f),b=(0,a.Ue)(g,bY);if("error"in b)throw new bf(b.error,"failed to get fee calculator");const{context:h,value:c}=b.result;return{context:h,value:null!==c?c.feeCalculator:null}}async getFeeForMessage(c,d){const e=c.serialize().toString("base64"),f=this._buildArgs([e],d),g=await this._rpcRequest("getFeeForMessage",f),b=(0,a.Ue)(g,h((0,a.AG)((0,a.Rx)())));if("error"in b)throw new bf(b.error,"failed to get slot");if(null===b.result)throw new Error("invalid blockhash");return b.result}async getRecentBlockhash(a){try{const b=await this.getRecentBlockhashAndContext(a);return b.value}catch(c){throw new Error("failed to get recent blockhash: "+c)}}async getLatestBlockhash(a){try{const b=await this.getLatestBlockhashAndContext(a);return b.value}catch(c){throw new Error("failed to get recent blockhash: "+c)}}async getLatestBlockhashAndContext(c){const{commitment:d,config:e}=bk(c),f=this._buildArgs([],d,void 0,e),g=await this._rpcRequest("getLatestBlockhash",f),b=(0,a.Ue)(g,bW);if("error"in b)throw new bf(b.error,"failed to get latest blockhash");return b.result}async getVersion(){const c=await this._rpcRequest("getVersion",[]),b=(0,a.Ue)(c,g(bo));if("error"in b)throw new bf(b.error,"failed to get version");return b.result}async getGenesisHash(){const c=await this._rpcRequest("getGenesisHash",[]),b=(0,a.Ue)(c,g((0,a.Z_)()));if("error"in b)throw new bf(b.error,"failed to get genesis hash");return b.result}async getBlock(d,e){const{commitment:f,config:g}=bk(e),h=this._buildArgsAtLeastConfirmed([d],f,void 0,g),i=await this._rpcRequest("getBlock",h),c=(0,a.Ue)(i,bQ);if("error"in c)throw new bf(c.error,"failed to get confirmed block");const b=c.result;return b?{...b,transactions:b.transactions.map(({transaction:a,meta:c,version:b})=>({meta:c,transaction:{...a,message:bm(b,a.message)},version:b}))}:b}async getBlockHeight(c){const{commitment:d,config:e}=bk(c),f=this._buildArgs([],d,void 0,e),h=await this._rpcRequest("getBlockHeight",f),b=(0,a.Ue)(h,g((0,a.Rx)()));if("error"in b)throw new bf(b.error,"failed to get block height information");return b.result}async getBlockProduction(b){let e,c;if("string"==typeof b)c=b;else if(b){const{commitment:f,...g}=b;c=f,e=g}const h=this._buildArgs([],c,"base64",e),i=await this._rpcRequest("getBlockProduction",h),d=(0,a.Ue)(i,bq);if("error"in d)throw new bf(d.error,"failed to get block production information");return d.result}async getTransaction(d,e){const{commitment:f,config:g}=bk(e),h=this._buildArgsAtLeastConfirmed([d],f,void 0,g),i=await this._rpcRequest("getTransaction",h),c=(0,a.Ue)(i,bT);if("error"in c)throw new bf(c.error,"failed to get transaction");const b=c.result;return b?{...b,transaction:{...b.transaction,message:bm(b.version,b.transaction.message)}}:b}async getParsedTransaction(c,d){const{commitment:e,config:f}=bk(d),g=this._buildArgsAtLeastConfirmed([c],e,"jsonParsed",f),h=await this._rpcRequest("getTransaction",g),b=(0,a.Ue)(h,bU);if("error"in b)throw new bf(b.error,"failed to get transaction");return b.result}async getParsedTransactions(b,c){const{commitment:g,config:h}=bk(c),d=b.map(a=>{const b=this._buildArgsAtLeastConfirmed([a],g,"jsonParsed",h);return{methodName:"getTransaction",args:b}}),e=await this._rpcBatchRequest(d),f=e.map(c=>{const b=(0,a.Ue)(c,bU);if("error"in b)throw new bf(b.error,"failed to get transactions");return b.result});return f}async getTransactions(b,c){const{commitment:g,config:h}=bk(c),d=b.map(a=>{const b=this._buildArgsAtLeastConfirmed([a],g,void 0,h);return{methodName:"getTransaction",args:b}}),e=await this._rpcBatchRequest(d),f=e.map(d=>{const c=(0,a.Ue)(d,bT);if("error"in c)throw new bf(c.error,"failed to get transactions");const b=c.result;return b?{...b,transaction:{...b.transaction,message:bm(b.version,b.transaction.message)}}:b});return f}async getConfirmedBlock(d,f){const g=this._buildArgsAtLeastConfirmed([d],f),h=await this._rpcRequest("getConfirmedBlock",g),b=(0,a.Ue)(h,bR);if("error"in b)throw new bf(b.error,"failed to get confirmed block");const c=b.result;if(!c)throw new Error("Confirmed block "+d+" not found");const e={...c,transactions:c.transactions.map(({transaction:a,meta:b})=>{const c=new aR(a.message);return{meta:b,transaction:{...a,message:c}}})};return{...e,transactions:e.transactions.map(({transaction:a,meta:b})=>({meta:b,transaction:aW.populate(a.message,a.signatures)}))}}async getBlocks(c,d,e){const f=this._buildArgsAtLeastConfirmed(void 0!==d?[c,d]:[c],e),h=await this._rpcRequest("getBlocks",f),b=(0,a.Ue)(h,g((0,a.IX)((0,a.Rx)())));if("error"in b)throw new bf(b.error,"failed to get blocks");return b.result}async getBlockSignatures(c,e){const f=this._buildArgsAtLeastConfirmed([c],e,void 0,{transactionDetails:"signatures",rewards:!1}),g=await this._rpcRequest("getBlock",f),b=(0,a.Ue)(g,bS);if("error"in b)throw new bf(b.error,"failed to get block");const d=b.result;if(!d)throw new Error("Block "+c+" not found");return d}async getConfirmedBlockSignatures(c,e){const f=this._buildArgsAtLeastConfirmed([c],e,void 0,{transactionDetails:"signatures",rewards:!1}),g=await this._rpcRequest("getConfirmedBlock",f),b=(0,a.Ue)(g,bS);if("error"in b)throw new bf(b.error,"failed to get confirmed block");const d=b.result;if(!d)throw new Error("Confirmed block "+c+" not found");return d}async getConfirmedTransaction(d,e){const f=this._buildArgsAtLeastConfirmed([d],e),g=await this._rpcRequest("getConfirmedTransaction",f),c=(0,a.Ue)(g,bT);if("error"in c)throw new bf(c.error,"failed to get transaction");const b=c.result;if(!b)return b;const h=new aR(b.transaction.message),i=b.transaction.signatures;return{...b,transaction:aW.populate(h,i)}}async getParsedConfirmedTransaction(c,d){const e=this._buildArgsAtLeastConfirmed([c],d,"jsonParsed"),f=await this._rpcRequest("getConfirmedTransaction",e),b=(0,a.Ue)(f,bU);if("error"in b)throw new bf(b.error,"failed to get confirmed transaction");return b.result}async getParsedConfirmedTransactions(b,f){const c=b.map(a=>{const b=this._buildArgsAtLeastConfirmed([a],f,"jsonParsed");return{methodName:"getConfirmedTransaction",args:b}}),d=await this._rpcBatchRequest(c),e=d.map(c=>{const b=(0,a.Ue)(c,bU);if("error"in b)throw new bf(b.error,"failed to get confirmed transactions");return b.result});return e}async getConfirmedSignaturesForAddress(h,b,g){let a={},i=await this.getFirstAvailableBlock();for(;!("until"in a)&& !(--b<=0)&&!(b<i);)try{const c=await this.getConfirmedBlockSignatures(b,"finalized");c.signatures.length>0&&(a.until=c.signatures[c.signatures.length-1].toString())}catch(d){if(d instanceof Error&&d.message.includes("skipped"))continue;throw d}let j=await this.getSlot("finalized");for(;!("before"in a)&&!(++g>j);)try{const e=await this.getConfirmedBlockSignatures(g);e.signatures.length>0&&(a.before=e.signatures[e.signatures.length-1].toString())}catch(f){if(f instanceof Error&&f.message.includes("skipped"))continue;throw f}const k=await this.getConfirmedSignaturesForAddress2(h,a);return k.map(a=>a.signature)}async getConfirmedSignaturesForAddress2(c,d,e){const f=this._buildArgsAtLeastConfirmed([c.toBase58()],e,void 0,d),g=await this._rpcRequest("getConfirmedSignaturesForAddress2",f),b=(0,a.Ue)(g,bE);if("error"in b)throw new bf(b.error,"failed to get confirmed signatures for address");return b.result}async getSignaturesForAddress(c,d,e){const f=this._buildArgsAtLeastConfirmed([c.toBase58()],e,void 0,d),g=await this._rpcRequest("getSignaturesForAddress",f),b=(0,a.Ue)(g,bF);if("error"in b)throw new bf(b.error,"failed to get signatures for address");return b.result}async getAddressLookupTable(a,d){const{context:e,value:b}=await this.getAccountInfoAndContext(a,d);let c=null;return null!==b&&(c=new bh({key:a,state:bh.deserialize(b.data)})),{context:e,value:c}}async getNonceAndContext(c,d){const{context:e,value:a}=await this.getAccountInfoAndContext(c,d);let b=null;return null!==a&&(b=a5.fromAccountData(a.data)),{context:e,value:b}}async getNonce(a,b){return await this.getNonceAndContext(a,b).then(a=>a.value).catch(b=>{throw new Error("failed to get nonce for account "+a.toBase58()+": "+b)})}async requestAirdrop(c,d){const e=await this._rpcRequest("requestAirdrop",[c.toBase58(),d]),b=(0,a.Ue)(e,bZ);if("error"in b)throw new bf(b.error,`airdrop to ${c.toBase58()} failed`);return b.result}async _blockhashWithExpiryBlockHeight(a){if(!a){for(;this._pollingBlockhash;)await a2(100);const b=Date.now()-this._blockhashInfo.lastFetch,c=b>=3e4;if(null!==this._blockhashInfo.latestBlockhash&&!c)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const d=Date.now(),b=this._blockhashInfo.latestBlockhash,e=b?b.blockhash:null;for(let c=0;c<50;c++){const a=await this.getLatestBlockhash("finalized");if(e!==a.blockhash)return this._blockhashInfo={latestBlockhash:a,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},a;await a2(200)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-d}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(c){const{commitment:d,config:e}=bk(c),f=this._buildArgs([],d,"base64",e),g=await this._rpcRequest("getStakeMinimumDelegation",f),b=(0,a.Ue)(g,h((0,a.Rx)()));if("error"in b)throw new bf(b.error,"failed to get stake minimum delegation");return b.result}async simulateTransaction(c,e,g){if("message"in c){const s=c,t=s.serialize(),u=p.lW.from(t).toString("base64");if(Array.isArray(e)|| void 0!==g)throw new Error("Invalid arguments");const h=e||{};h.encoding="base64","commitment"in h||(h.commitment=this.commitment);const v=[u,h],w=await this._rpcRequest("simulateTransaction",v),j=(0,a.Ue)(w,bp);if("error"in j)throw new Error("failed to simulate transaction: "+j.error.message);return j.result}let b;if(c instanceof aW){let k=c;(b=new aW).feePayer=k.feePayer,b.instructions=c.instructions,b.nonceInfo=k.nonceInfo,b.signatures=k.signatures}else(b=aW.populate(c))._message=b._json=void 0;if(void 0!==e&&!Array.isArray(e))throw new Error("Invalid arguments");const f=e;if(b.nonceInfo&&f)b.sign(...f);else{let n=this._disableBlockhashCaching;for(;;){const o=await this._blockhashWithExpiryBlockHeight(n);if(b.lastValidBlockHeight=o.lastValidBlockHeight,b.recentBlockhash=o.blockhash,!f)break;if(b.sign(...f),!b.signature)throw new Error("!signature");const l=b.signature.toString("base64");if(this._blockhashInfo.simulatedSignatures.includes(l)||this._blockhashInfo.transactionSignatures.includes(l))n=!0;else{this._blockhashInfo.simulatedSignatures.push(l);break}}}const q=b._compile(),x=q.serialize(),y=b._serialize(x),z=y.toString("base64"),m={encoding:"base64",commitment:this.commitment};if(g){const A=(Array.isArray(g)?g:q.nonProgramIds()).map(a=>a.toBase58());m.accounts={encoding:"base64",addresses:A}}f&&(m.sigVerify=!0);const B=await this._rpcRequest("simulateTransaction",[z,m]),d=(0,a.Ue)(B,bp);if("error"in d){let i;if("data"in d.error&&(i=d.error.data.logs)&&Array.isArray(i)){const r="\n    ",C=r+i.join(r);console.error(d.error.message,C)}throw new be("failed to simulate transaction: "+d.error.message,i)}return d.result}async sendTransaction(a,b,c){if("version"in a){if(b&&Array.isArray(b))throw new Error("Invalid arguments");const h=a.serialize();return await this.sendRawTransaction(h,c)}if(void 0===b||!Array.isArray(b))throw new Error("Invalid arguments");const d=b;if(a.nonceInfo)a.sign(...d);else{let e=this._disableBlockhashCaching;for(;;){const f=await this._blockhashWithExpiryBlockHeight(e);if(a.lastValidBlockHeight=f.lastValidBlockHeight,a.recentBlockhash=f.blockhash,a.sign(...d),!a.signature)throw new Error("!signature");const g=a.signature.toString("base64");if(this._blockhashInfo.transactionSignatures.includes(g))e=!0;else{this._blockhashInfo.transactionSignatures.push(g);break}}}const i=a.serialize();return await this.sendRawTransaction(i,c)}async sendRawTransaction(a,b){const c=aH(a).toString("base64"),d=await this.sendEncodedTransaction(c,b);return d}async sendEncodedTransaction(h,b){const c={encoding:"base64"},e=b&&b.skipPreflight,f=b&&b.preflightCommitment||this.commitment;b&&null!=b.maxRetries&&(c.maxRetries=b.maxRetries),b&&null!=b.minContextSlot&&(c.minContextSlot=b.minContextSlot),e&&(c.skipPreflight=e),f&&(c.preflightCommitment=f);const i=await this._rpcRequest("sendTransaction",[h,c]),d=(0,a.Ue)(i,b$);if("error"in d){let g;throw"data"in d.error&&(g=d.error.data.logs),new be("failed to send transaction: "+d.error.message,g)}return d.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{this._rpcWebSocket.notify("ping").catch(()=>{})},5e3),this._updateSubscriptions()}_wsOnError(a){this._rpcWebSocketConnected=!1,console.error("ws error:",a.message)}_wsOnClose(a){if(this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration++,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),1e3===a){this._updateSubscriptions();return}this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([a,b])=>{this._subscriptionsByHash[a]={...b,state:"pending"}})}async _updateSubscriptions(){if(0===Object.keys(this._subscriptionsByHash).length){this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(a){a instanceof Error&&console.log(`Error when closing socket connection: ${a.message}`)}},500));return}if(null!==this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected){this._rpcWebSocket.connect();return}const a=this._rpcWebSocketGeneration,b=()=>a===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map(async c=>{const a=this._subscriptionsByHash[c];if(void 0!==a)switch(a.state){case"pending":case"unsubscribed":if(0===a.callbacks.size){delete this._subscriptionsByHash[c],"unsubscribed"===a.state&&delete this._subscriptionCallbacksByServerSubscriptionId[a.serverSubscriptionId],await this._updateSubscriptions();return}await (async()=>{const{args:d,method:e}=a;try{this._subscriptionsByHash[c]={...a,state:"subscribing"};const f=await this._rpcWebSocket.call(e,d);this._subscriptionsByHash[c]={...a,serverSubscriptionId:f,state:"subscribed"},this._subscriptionCallbacksByServerSubscriptionId[f]=a.callbacks,await this._updateSubscriptions()}catch(g){if(g instanceof Error&&console.error(`${e} error for argument`,d,g.message),!b())return;this._subscriptionsByHash[c]={...a,state:"pending"},await this._updateSubscriptions()}})();break;case"subscribed":0===a.callbacks.size&&await (async()=>{const{serverSubscriptionId:d,unsubscribeMethod:e}=a;if(this._subscriptionsAutoDisposedByRpc.has(d))this._subscriptionsAutoDisposedByRpc.delete(d);else{this._subscriptionsByHash[c]={...a,state:"unsubscribing"};try{await this._rpcWebSocket.call(e,[d])}catch(f){if(f instanceof Error&&console.error(`${e} error:`,f.message),!b())return;this._subscriptionsByHash[c]={...a,state:"subscribed"},await this._updateSubscriptions();return}}this._subscriptionsByHash[c]={...a,state:"unsubscribed"},await this._updateSubscriptions()})();break}}))}_handleServerNotification(b,c){const a=this._subscriptionCallbacksByServerSubscriptionId[b];void 0!==a&&a.forEach(a=>{try{a(...c)}catch(b){console.error(b)}})}_wsOnAccountNotification(c){const{result:b,subscription:d}=(0,a.Ue)(c,bG);this._handleServerNotification(d,[b.value,b.context])}_makeSubscription(a,b){const c=this._nextClientSubscriptionId++,d=bb([a.method,b],!0),e=this._subscriptionsByHash[d];return void 0===e?this._subscriptionsByHash[d]={...a,args:b,callbacks:new Set([a.callback]),state:"pending"}:e.callbacks.add(a.callback),this._subscriptionDisposeFunctionsByClientSubscriptionId[c]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[c];const b=this._subscriptionsByHash[d];aP(void 0!==b,`Could not find a \`Subscription\` when tearing down client subscription #${c}`),b.callbacks.delete(a.callback),await this._updateSubscriptions()},this._updateSubscriptions(),c}onAccountChange(a,b,c){const d=this._buildArgs([a.toBase58()],c||this._commitment||"finalized","base64");return this._makeSubscription({callback:b,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},d)}async removeAccountChangeListener(a){await this._unsubscribeClientSubscription(a,"account change")}_wsOnProgramAccountNotification(c){const{result:b,subscription:d}=(0,a.Ue)(c,bH);this._handleServerNotification(d,[{accountId:b.value.pubkey,accountInfo:b.value.account},b.context])}onProgramAccountChange(b,c,d,a){const e=this._buildArgs([b.toBase58()],d||this._commitment||"finalized","base64",a?{filters:a}:void 0);return this._makeSubscription({callback:c,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},e)}async removeProgramAccountChangeListener(a){await this._unsubscribeClientSubscription(a,"program account change")}onLogs(a,b,c){const d=this._buildArgs(["object"==typeof a?{mentions:[a.toString()]}:a],c||this._commitment||"finalized");return this._makeSubscription({callback:b,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},d)}async removeOnLogsListener(a){await this._unsubscribeClientSubscription(a,"logs")}_wsOnLogsNotification(c){const{result:b,subscription:d}=(0,a.Ue)(c,b_);this._handleServerNotification(d,[b.value,b.context])}_wsOnSlotNotification(b){const{result:c,subscription:d}=(0,a.Ue)(b,bI);this._handleServerNotification(d,[c])}onSlotChange(a){return this._makeSubscription({callback:a,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(a){await this._unsubscribeClientSubscription(a,"slot change")}_wsOnSlotUpdatesNotification(b){const{result:c,subscription:d}=(0,a.Ue)(b,bJ);this._handleServerNotification(d,[c])}onSlotUpdate(a){return this._makeSubscription({callback:a,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(a){await this._unsubscribeClientSubscription(a,"slot update")}async _unsubscribeClientSubscription(a,c){const b=this._subscriptionDisposeFunctionsByClientSubscriptionId[a];b?await b():console.warn(`Ignored unsubscribe request because an active subscription with id \`${a}\` for '${c}' events could not be found.`)}_buildArgs(e,f,b,c){const d=f||this._commitment;if(d||b||c){let a={};b&&(a.encoding=b),d&&(a.commitment=d),c&&(a=Object.assign(a,c)),e.push(a)}return e}_buildArgsAtLeastConfirmed(c,a,d,e){const b=a||this._commitment;if(b&&!["confirmed","finalized"].includes(b))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(c,a,d,e)}_wsOnSignatureNotification(d){const{result:b,subscription:c}=(0,a.Ue)(d,bK);"receivedSignature"!==b.value&&this._subscriptionsAutoDisposedByRpc.add(c),this._handleServerNotification(c,"receivedSignature"===b.value?[{type:"received"},b.context]:[{type:"status",result:b.value},b.context])}onSignature(a,e,b){const c=this._buildArgs([a],b||this._commitment||"finalized"),d=this._makeSubscription({callback:(a,b)=>{if("status"===a.type){e(a.result,b);try{this.removeSignatureListener(d)}catch(c){}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},c);return d}onSignatureWithOptions(b,g,a){const{commitment:c,...d}={...a,commitment:a&&a.commitment||this._commitment||"finalized"},e=this._buildArgs([b],c,void 0,d),f=this._makeSubscription({callback:(a,b)=>{g(a,b);try{this.removeSignatureListener(f)}catch(c){}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},e);return f}async removeSignatureListener(a){await this._unsubscribeClientSubscription(a,"signature result")}_wsOnRootNotification(b){const{result:c,subscription:d}=(0,a.Ue)(b,bL);this._handleServerNotification(d,[c])}onRootChange(a){return this._makeSubscription({callback:a,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(a){await this._unsubscribeClientSubscription(a,"root change")}}class b2{constructor(a){this._keypair=void 0,this._keypair=null!=a?a:aC()}static generate(){return new b2(aC())}static fromSecretKey(a,c){if(64!==a.byteLength)throw new Error("bad secret key size");const d=a.slice(32,64);if(!c||!c.skipValidation){const e=a.slice(0,32),f=aD(e);for(let b=0;b<32;b++)if(d[b]!==f[b])throw new Error("provided secretKey is invalid")}return new b2({publicKey:d,secretKey:a})}static fromSeed(b){const c=aD(b),a=new Uint8Array(64);return a.set(b),a.set(c,32),new b2({publicKey:c,secretKey:a})}get publicKey(){return new c(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}const b3=Object.freeze({CreateLookupTable:{index:0,layout:b.n_([b.Jq("instruction"),k("recentSlot"),b.u8("bumpSeed")])},FreezeLookupTable:{index:1,layout:b.n_([b.Jq("instruction")])},ExtendLookupTable:{index:2,layout:b.n_([b.Jq("instruction"),k(),b.A9(d(),b.cv(b.Jq(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:b.n_([b.Jq("instruction")])},CloseLookupTable:{index:4,layout:b.n_([b.Jq("instruction")])}});(class{constructor(){}static createLookupTable(a){const[b,d]=c.findProgramAddressSync([a.authority.toBuffer(),(0,ax.k$)(BigInt(a.recentSlot),8)],this.programId),e=b3.CreateLookupTable,f=a3(e,{recentSlot:BigInt(a.recentSlot),bumpSeed:d}),g=[{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:a.authority,isSigner:!0,isWritable:!1},{pubkey:a.payer,isSigner:!0,isWritable:!0},{pubkey:S.programId,isSigner:!1,isWritable:!1}];return[new aV({programId:this.programId,keys:g,data:f}),b]}static freezeLookupTable(a){const b=b3.FreezeLookupTable,c=a3(b),d=[{pubkey:a.lookupTable,isSigner:!1,isWritable:!0},{pubkey:a.authority,isSigner:!0,isWritable:!1}];return new aV({programId:this.programId,keys:d,data:c})}static extendLookupTable(a){const c=b3.ExtendLookupTable,d=a3(c,{addresses:a.addresses.map(a=>a.toBytes())}),b=[{pubkey:a.lookupTable,isSigner:!1,isWritable:!0},{pubkey:a.authority,isSigner:!0,isWritable:!1}];return a.payer&&b.push({pubkey:a.payer,isSigner:!0,isWritable:!0},{pubkey:S.programId,isSigner:!1,isWritable:!1}),new aV({programId:this.programId,keys:b,data:d})}static deactivateLookupTable(a){const b=b3.DeactivateLookupTable,c=a3(b),d=[{pubkey:a.lookupTable,isSigner:!1,isWritable:!0},{pubkey:a.authority,isSigner:!0,isWritable:!1}];return new aV({programId:this.programId,keys:d,data:c})}static closeLookupTable(a){const b=b3.CloseLookupTable,c=a3(b),d=[{pubkey:a.lookupTable,isSigner:!1,isWritable:!0},{pubkey:a.authority,isSigner:!0,isWritable:!1},{pubkey:a.recipient,isSigner:!1,isWritable:!0}];return new aV({programId:this.programId,keys:d,data:c})}}).programId=new c("AddressLookupTab1e1111111111111111111111111");const b4=Object.freeze({RequestUnits:{index:0,layout:b.n_([b.u8("instruction"),b.Jq("units"),b.Jq("additionalFee")])},RequestHeapFrame:{index:1,layout:b.n_([b.u8("instruction"),b.Jq("bytes")])},SetComputeUnitLimit:{index:2,layout:b.n_([b.u8("instruction"),b.Jq("units")])},SetComputeUnitPrice:{index:3,layout:b.n_([b.u8("instruction"),k("microLamports")])}});(class{constructor(){}static requestUnits(a){const b=b4.RequestUnits,c=a3(b,a);return new aV({keys:[],programId:this.programId,data:c})}static requestHeapFrame(a){const b=b4.RequestHeapFrame,c=a3(b,a);return new aV({keys:[],programId:this.programId,data:c})}static setComputeUnitLimit(a){const b=b4.SetComputeUnitLimit,c=a3(b,a);return new aV({keys:[],programId:this.programId,data:c})}static setComputeUnitPrice(a){const b=b4.SetComputeUnitPrice,c=a3(b,{microLamports:BigInt(a.microLamports)});return new aV({keys:[],programId:this.programId,data:c})}}).programId=new c("ComputeBudget111111111111111111111111111111");const b5=b.n_([b.u8("numSignatures"),b.u8("padding"),b.KB("signatureOffset"),b.KB("signatureInstructionIndex"),b.KB("publicKeyOffset"),b.KB("publicKeyInstructionIndex"),b.KB("messageDataOffset"),b.KB("messageDataSize"),b.KB("messageInstructionIndex")]);class ap{constructor(){}static createInstructionWithPublicKey(j){const{publicKey:b,message:d,signature:c,instructionIndex:i}=j;aP(32===b.length,`Public Key must be 32 bytes but received ${b.length} bytes`),aP(64===c.length,`Signature must be 64 bytes but received ${c.length} bytes`);const e=b5.span,f=e+b.length,g=f+c.length,a=p.lW.alloc(g+d.length),h=null==i?65535:i;return b5.encode({numSignatures:1,padding:0,signatureOffset:f,signatureInstructionIndex:h,publicKeyOffset:e,publicKeyInstructionIndex:h,messageDataOffset:g,messageDataSize:d.length,messageInstructionIndex:h},a),a.fill(b,e),a.fill(c,f),a.fill(d,g),new aV({keys:[],programId:ap.programId,data:a})}static createInstructionWithPrivateKey(d){const{privateKey:a,message:b,instructionIndex:e}=d;aP(64===a.length,`Private key must be 64 bytes but received ${a.length} bytes`);try{const c=b2.fromSecretKey(a),f=c.publicKey.toBytes(),g=aF(b,c.secretKey);return this.createInstructionWithPublicKey({publicKey:f,message:b,signature:g,instructionIndex:e})}catch(h){throw new Error(`Error creating instruction; ${h}`)}}}ap.programId=new c("Ed25519SigVerify111111111111111111111111111"),q.P6.hmacSha256Sync=(a,...b)=>{const c=aB.b.create(av.J,a);return b.forEach(a=>c.update(a)),c.digest()};const b6=(a,b)=>q.kS(a,b,{der:!1,recovered:!0});q.P6.isValidPrivateKey;const b7=q.$3,b8=b.n_([b.u8("numSignatures"),b.KB("signatureOffset"),b.u8("signatureInstructionIndex"),b.KB("ethAddressOffset"),b.u8("ethAddressInstructionIndex"),b.KB("messageDataOffset"),b.KB("messageDataSize"),b.u8("messageInstructionIndex"),b.Ik(20,"ethAddress"),b.Ik(64,"signature"),b.u8("recoveryId")]);class aq{constructor(){}static publicKeyToEthAddress(a){aP(64===a.length,`Public key must be 64 bytes but received ${a.length} bytes`);try{return p.lW.from((0,aA.fr)(aH(a))).slice(-20)}catch(b){throw new Error(`Error constructing Ethereum address: ${b}`)}}static createInstructionWithPublicKey(a){const{publicKey:b,message:c,signature:d,recoveryId:e,instructionIndex:f}=a;return aq.createInstructionWithEthAddress({ethAddress:aq.publicKeyToEthAddress(b),message:c,signature:d,recoveryId:e,instructionIndex:f})}static createInstructionWithEthAddress(h){const{ethAddress:a,message:c,signature:f,recoveryId:i,instructionIndex:d=0}=h;let b;aP(20===(b="string"==typeof a?a.startsWith("0x")?p.lW.from(a.substr(2),"hex"):p.lW.from(a,"hex"):a).length,`Address must be 20 bytes but received ${b.length} bytes`);const g=12+b.length,j=g+f.length+1,e=p.lW.alloc(b8.span+c.length);return b8.encode({numSignatures:1,signatureOffset:g,signatureInstructionIndex:d,ethAddressOffset:12,ethAddressInstructionIndex:d,messageDataOffset:j,messageDataSize:c.length,messageInstructionIndex:d,signature:aH(f),ethAddress:aH(b),recoveryId:i},e),e.fill(aH(c),b8.span),new aV({keys:[],programId:aq.programId,data:e})}static createInstructionWithPrivateKey(d){const{privateKey:a,message:b,instructionIndex:e}=d;aP(32===a.length,`Private key must be 32 bytes but received ${a.length} bytes`);try{const c=aH(a),f=b7(c,!1).slice(1),g=p.lW.from((0,aA.fr)(aH(b))),[h,i]=b6(g,c);return this.createInstructionWithPublicKey({publicKey:f,message:b,signature:h,recoveryId:i,instructionIndex:e})}catch(j){throw new Error(`Error creating instruction; ${j}`)}}}aq.programId=new c("KeccakSecp256k11111111111111111111111111111");const b9=new c("StakeConfig11111111111111111111111111111111");class D{constructor(a,b,c){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=a,this.epoch=b,this.custodian=c}}D.default=new D(0,0,c.default);const ca=Object.freeze({Initialize:{index:0,layout:b.n_([b.Jq("instruction"),((a="authorized")=>b.n_([d("staker"),d("withdrawer")],a))(),((a="lockup")=>b.n_([b.gM("unixTimestamp"),b.gM("epoch"),d("custodian")],a))()])},Authorize:{index:1,layout:b.n_([b.Jq("instruction"),d("newAuthorized"),b.Jq("stakeAuthorizationType")])},Delegate:{index:2,layout:b.n_([b.Jq("instruction")])},Split:{index:3,layout:b.n_([b.Jq("instruction"),b.gM("lamports")])},Withdraw:{index:4,layout:b.n_([b.Jq("instruction"),b.gM("lamports")])},Deactivate:{index:5,layout:b.n_([b.Jq("instruction")])},Merge:{index:7,layout:b.n_([b.Jq("instruction")])},AuthorizeWithSeed:{index:8,layout:b.n_([b.Jq("instruction"),d("newAuthorized"),b.Jq("stakeAuthorizationType"),l("authoritySeed"),d("authorityOwner")])}});Object.freeze({Staker:{index:0},Withdrawer:{index:1}});class E{constructor(){}static initialize(c){const{stakePubkey:d,authorized:b,lockup:e}=c,a=e||D.default,f=ca.Initialize,g=a3(f,{authorized:{staker:aH(b.staker.toBuffer()),withdrawer:aH(b.withdrawer.toBuffer())},lockup:{unixTimestamp:a.unixTimestamp,epoch:a.epoch,custodian:aH(a.custodian.toBuffer())}}),h={keys:[{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:a_,isSigner:!1,isWritable:!1}],programId:this.programId,data:g};return new aV(h)}static createAccountWithSeed(a){const b=new aW;b.add(S.createAccountWithSeed({fromPubkey:a.fromPubkey,newAccountPubkey:a.stakePubkey,basePubkey:a.basePubkey,seed:a.seed,lamports:a.lamports,space:this.space,programId:this.programId}));const{stakePubkey:c,authorized:d,lockup:e}=a;return b.add(this.initialize({stakePubkey:c,authorized:d,lockup:e}))}static createAccount(a){const b=new aW;b.add(S.createAccount({fromPubkey:a.fromPubkey,newAccountPubkey:a.stakePubkey,lamports:a.lamports,space:this.space,programId:this.programId}));const{stakePubkey:c,authorized:d,lockup:e}=a;return b.add(this.initialize({stakePubkey:c,authorized:d,lockup:e}))}static delegate(a){const{stakePubkey:b,authorizedPubkey:c,votePubkey:d}=a,e=ca.Delegate,f=a3(e);return new aW().add({keys:[{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:aZ,isSigner:!1,isWritable:!1},{pubkey:a0,isSigner:!1,isWritable:!1},{pubkey:b9,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!0,isWritable:!1}],programId:this.programId,data:f})}static authorize(c){const{stakePubkey:d,authorizedPubkey:e,newAuthorizedPubkey:f,stakeAuthorizationType:g,custodianPubkey:a}=c,h=ca.Authorize,i=a3(h,{newAuthorized:aH(f.toBuffer()),stakeAuthorizationType:g.index}),b=[{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:aZ,isSigner:!1,isWritable:!0},{pubkey:e,isSigner:!0,isWritable:!1}];return a&&b.push({pubkey:a,isSigner:!1,isWritable:!1}),new aW().add({keys:b,programId:this.programId,data:i})}static authorizeWithSeed(c){const{stakePubkey:d,authorityBase:e,authoritySeed:f,authorityOwner:g,newAuthorizedPubkey:h,stakeAuthorizationType:i,custodianPubkey:a}=c,j=ca.AuthorizeWithSeed,k=a3(j,{newAuthorized:aH(h.toBuffer()),stakeAuthorizationType:i.index,authoritySeed:f,authorityOwner:aH(g.toBuffer())}),b=[{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:aZ,isSigner:!1,isWritable:!1}];return a&&b.push({pubkey:a,isSigner:!1,isWritable:!1}),new aW().add({keys:b,programId:this.programId,data:k})}static splitInstruction(a){const{stakePubkey:b,authorizedPubkey:c,splitStakePubkey:d,lamports:e}=a,f=ca.Split,g=a3(f,{lamports:e});return new aV({keys:[{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!0,isWritable:!1}],programId:this.programId,data:g})}static split(a){const b=new aW;return b.add(S.createAccount({fromPubkey:a.authorizedPubkey,newAccountPubkey:a.splitStakePubkey,lamports:0,space:this.space,programId:this.programId})),b.add(this.splitInstruction(a))}static splitWithSeed(c){const{stakePubkey:d,authorizedPubkey:e,splitStakePubkey:a,basePubkey:f,seed:g,lamports:h}=c,b=new aW;return b.add(S.allocate({accountPubkey:a,basePubkey:f,seed:g,space:this.space,programId:this.programId})),b.add(this.splitInstruction({stakePubkey:d,authorizedPubkey:e,splitStakePubkey:a,lamports:h}))}static merge(a){const{stakePubkey:b,sourceStakePubKey:c,authorizedPubkey:d}=a,e=ca.Merge,f=a3(e);return new aW().add({keys:[{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:aZ,isSigner:!1,isWritable:!1},{pubkey:a0,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!0,isWritable:!1}],programId:this.programId,data:f})}static withdraw(c){const{stakePubkey:d,authorizedPubkey:e,toPubkey:f,lamports:g,custodianPubkey:a}=c,h=ca.Withdraw,i=a3(h,{lamports:g}),b=[{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:aZ,isSigner:!1,isWritable:!1},{pubkey:a0,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!0,isWritable:!1}];return a&&b.push({pubkey:a,isSigner:!1,isWritable:!1}),new aW().add({keys:b,programId:this.programId,data:i})}static deactivate(a){const{stakePubkey:b,authorizedPubkey:c}=a,d=ca.Deactivate,e=a3(d);return new aW().add({keys:[{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:aZ,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!0,isWritable:!1}],programId:this.programId,data:e})}}E.programId=new c("Stake11111111111111111111111111111111111111"),E.space=200;const cb=Object.freeze({InitializeAccount:{index:0,layout:b.n_([b.Jq("instruction"),((a="voteInit")=>b.n_([d("nodePubkey"),d("authorizedVoter"),d("authorizedWithdrawer"),b.u8("commission")],a))()])},Authorize:{index:1,layout:b.n_([b.Jq("instruction"),d("newAuthorized"),b.Jq("voteAuthorizationType")])},Withdraw:{index:3,layout:b.n_([b.Jq("instruction"),b.gM("lamports")])},AuthorizeWithSeed:{index:10,layout:b.n_([b.Jq("instruction"),((a="voteAuthorizeWithSeedArgs")=>b.n_([b.Jq("voteAuthorizationType"),d("currentAuthorityDerivedKeyOwnerPubkey"),l("currentAuthorityDerivedKeySeed"),d("newAuthorized")],a))()])}});Object.freeze({Voter:{index:0},Withdrawer:{index:1}});class F{constructor(){}static initializeAccount(b){const{votePubkey:c,nodePubkey:d,voteInit:a}=b,e=cb.InitializeAccount,f=a3(e,{voteInit:{nodePubkey:aH(a.nodePubkey.toBuffer()),authorizedVoter:aH(a.authorizedVoter.toBuffer()),authorizedWithdrawer:aH(a.authorizedWithdrawer.toBuffer()),commission:a.commission}}),g={keys:[{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:a_,isSigner:!1,isWritable:!1},{pubkey:aZ,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!0,isWritable:!1}],programId:this.programId,data:f};return new aV(g)}static createAccount(a){const b=new aW;return b.add(S.createAccount({fromPubkey:a.fromPubkey,newAccountPubkey:a.votePubkey,lamports:a.lamports,space:this.space,programId:this.programId})),b.add(this.initializeAccount({votePubkey:a.votePubkey,nodePubkey:a.voteInit.nodePubkey,voteInit:a.voteInit}))}static authorize(a){const{votePubkey:b,authorizedPubkey:c,newAuthorizedPubkey:d,voteAuthorizationType:e}=a,f=cb.Authorize,g=a3(f,{newAuthorized:aH(d.toBuffer()),voteAuthorizationType:e.index});return new aW().add({keys:[{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:aZ,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!0,isWritable:!1}],programId:this.programId,data:g})}static authorizeWithSeed(a){const{currentAuthorityDerivedKeyBasePubkey:b,currentAuthorityDerivedKeyOwnerPubkey:c,currentAuthorityDerivedKeySeed:d,newAuthorizedPubkey:e,voteAuthorizationType:f,votePubkey:g}=a,h=cb.AuthorizeWithSeed,i=a3(h,{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:aH(c.toBuffer()),currentAuthorityDerivedKeySeed:d,newAuthorized:aH(e.toBuffer()),voteAuthorizationType:f.index}});return new aW().add({keys:[{pubkey:g,isSigner:!1,isWritable:!0},{pubkey:aZ,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}static withdraw(a){const{votePubkey:b,authorizedWithdrawerPubkey:c,lamports:d,toPubkey:e}=a,f=cb.Withdraw,g=a3(f,{lamports:d});return new aW().add({keys:[{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!0,isWritable:!1}],programId:this.programId,data:g})}static safeWithdraw(a,b,c){if(a.lamports>b-c)throw new Error("Withdraw will leave vote account with insuffcient funds.");return F.withdraw(a)}}F.programId=new c("Vote111111111111111111111111111111111111111"),F.space=3731;const cc=new c("Va1idator1nfo111111111111111111111111111111"),cd=(0,a.dt)({name:(0,a.Z_)(),website:(0,a.jt)((0,a.Z_)()),details:(0,a.jt)((0,a.Z_)()),keybaseUsername:(0,a.jt)((0,a.Z_)())});class ce{constructor(a,b){this.key=void 0,this.info=void 0,this.key=a,this.info=b}static fromConfigData(f){let a=[...f];const g=aN(a);if(2!==g)return null;const b=[];for(let d=0;d<2;d++){const h=new c(a.slice(0,aI));a=a.slice(aI);const i=1===a.slice(0,1)[0];a=a.slice(1),b.push({publicKey:h,isSigner:i})}if(b[0].publicKey.equals(cc)&&b[1].isSigner){const j=l().decode(Buffer.from(a)),e=JSON.parse(j);return assert$1(e,cd),new ce(b[1].publicKey,e)}return null}}new c("Vote111111111111111111111111111111111111111");const cf=b.n_([d("nodePubkey"),d("authorizedWithdrawer"),b.u8("commission"),b._O(),b.A9(b.n_([b._O("slot"),b.Jq("confirmationCount")]),b.cv(b.Jq(),-8),"votes"),b.u8("rootSlotValid"),b._O("rootSlot"),b._O(),b.A9(b.n_([b._O("epoch"),d("authorizedVoter")]),b.cv(b.Jq(),-8),"authorizedVoters"),b.n_([b.A9(b.n_([d("authorizedPubkey"),b._O("epochOfLastAuthorizedSwitch"),b._O("targetEpoch")]),32,"buf"),b._O("idx"),b.u8("isEmpty")],"priorVoters"),b._O(),b.A9(b.n_([b._O("epoch"),b._O("credits"),b._O("prevCredits")]),b.cv(b.Jq(),-8),"epochCredits"),b.n_([b._O("slot"),b._O("timestamp")],"lastTimestamp")]);class cg{constructor(a){this.nodePubkey=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.rootSlot=void 0,this.votes=void 0,this.authorizedVoters=void 0,this.priorVoters=void 0,this.epochCredits=void 0,this.lastTimestamp=void 0,this.nodePubkey=a.nodePubkey,this.authorizedWithdrawer=a.authorizedWithdrawer,this.commission=a.commission,this.rootSlot=a.rootSlot,this.votes=a.votes,this.authorizedVoters=a.authorizedVoters,this.priorVoters=a.priorVoters,this.epochCredits=a.epochCredits,this.lastTimestamp=a.lastTimestamp}static fromAccountData(d){const a=cf.decode(aH(d),4);let b=a.rootSlot;return a.rootSlotValid||(b=null),new cg({nodePubkey:new c(a.nodePubkey),authorizedWithdrawer:new c(a.authorizedWithdrawer),commission:a.commission,votes:a.votes,rootSlot:b,authorizedVoters:a.authorizedVoters.map(ch),priorVoters:cj(a.priorVoters),epochCredits:a.epochCredits,lastTimestamp:a.lastTimestamp})}}function ch({authorizedVoter:a,epoch:b}){return{epoch:b,authorizedVoter:new c(a)}}function ci({authorizedPubkey:a,epochOfLastAuthorizedSwitch:b,targetEpoch:d}){return{authorizedPubkey:new c(a),epochOfLastAuthorizedSwitch:b,targetEpoch:d}}function cj({buf:a,idx:b,isEmpty:c}){return c?[]:[...a.slice(b+1).map(ci),...a.slice(0,b).map(ci)]}}}])